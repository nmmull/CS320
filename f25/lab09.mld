{0 Lab 8: Formal Grammar Worksheet}

{1 Ambiguity}

{@text[
<a> ::= <b> <c>
<b> ::= <b> y | x
<c> ::= <d> | <d> y
<d> ::= z <b> | z
]}

{ol

{- Give a leftmost derivation of the sentence [xyz].}

{- Draw a parse tree for the sentence [xyz].}

{- Find the {i shortest} sentence accepted by the above grammar which
has multiple parse trees. Draw both parse trees.}

}

{1 Revisiting S-Expressions}

Use Menhir and OCamllex to build a parser for S-expressions which
targets [string sexpr]. Recall the ADT definition of [sexpr]:

{[
type 'a sexpr = Atom of 'a | List of 'a sexpr list
]}

You should use the following regular expression for atoms in your
lexer:

{[
let atom = [^ ' ' '\t' '\n' '\r' '(' ')']+
]}

This expression matches any nonempty sequence of non-whitespace
non-parentheses characters.

{1 Designing Grammars}

Design an unambiguous grammar for Boolean expressions over the
constants [True] and [False] in Python.  When you're done, compare
with the
{{:https://docs.python.org/3/reference/expressions.html#boolean-operations}Python
grammar for Boolean operators}.

{b Challenge.} We just discussed parser generators in lecture. If you
have time, build a parser for these expressions using [menhir] and
[ocamllex].
