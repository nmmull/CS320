<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>topics (Spring-2024.topics)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">Spring-2024</a> &#x00BB; topics</nav><header class="odoc-preamble"><h2 id="topics"><a href="#topics" class="anchor"></a>Topics</h2></header><nav class="odoc-toc"><ul><li><a href="#course_intro">What is this course?</a></li><li><a href="#beginning-ocaml">Beginning Ocaml</a><ul><li><a href="#ocaml_intro_i">Expressions</a></li><li><a href="#ocaml_intro_ii">Functions</a></li><li><a href="#ocaml_intro_iii">Unions and Products</a></li><li><a href="#ocaml_intro_iv">Lists and IO</a></li></ul></li><li><a href="#ind_types">Inductive Types</a><ul><li><a href="#ind_types_i">Introduction</a></li><li><a href="#ind_types_ii">Examples</a></li></ul></li><li><a href="#ho">Higher-Order Programming</a><ul><li><a href="#ho_i">Maps and Filters</a></li><li><a href="#ho_ii">Folds and Examples</a></li></ul></li><li><a href="#inter">Intermediate OCaml</a><ul><li><a href="#inter_i">Options, Monads and Modules</a></li></ul></li><li><a href="#grammar">Formal Grammar</a><ul><li><a href="#grammar_i">Introduction</a></li><li><a href="#grammar_ii">Ambiguity</a></li><li><a href="#grammar_iii">Extended BNF and Regular Expressions</a></li></ul></li><li><a href="#parse">Parsing</a><ul><li><a href="#parse_i">Introduction</a></li><li><a href="#parse_ii">General Parsing</a></li><li><a href="#parse_iii">Combinators</a></li></ul></li><li><a href="#sem">Formal Semantics</a><ul><li><a href="#sem_i">Operational Semantics</a></li><li><a href="#sem_ii">Applying Rules</a></li><li><a href="#sem_iii">Designing Rules</a></li></ul></li><li><a href="#sub">Variables and Subprograms</a><ul><li><a href="#sub_i">Variable Binding and Scoping</a></li><li><a href="#sub_ii">Parameter Passing</a></li><li><a href="#sub_iii">Activation Records and Closures</a></li><li><a href="#sub_iv">Substitution Model</a></li></ul></li><li><a href="#adv">Advanced Topics</a><ul><li><a href="#adv_topic_i">Compilation</a></li><li><a href="#adv_topic_ii">The Lean Theorem Prover</a></li></ul></li></ul></nav><div class="odoc-content"><h3 id="course_intro"><a href="#course_intro" class="anchor"></a>What is this course?</h3><p><b>Overview:</b> We discuss the expectations of the course, and give a rough outline of the topics that will be covered. We will also touch on the benefits of the functional paradigm.</p><p><b>Keywords:</b> course structure, course policy, OCaml, functional programming</p><p><b>Required reading:</b> OCaml Programming (OCP) <a href="https://cs3110.github.io/textbook/chapters/intro/intro.html">1.1-1.3: Better programming through OCaml</a></p><p><b>Additional information:</b> Homework 0 is released. <i>It's not graded</i> but it's important that you complete it so that you're set up to submit the later assignments.</p><h3 id="beginning-ocaml"><a href="#beginning-ocaml" class="anchor"></a>Beginning Ocaml</h3><h4 id="ocaml_intro_i"><a href="#ocaml_intro_i" class="anchor"></a>Expressions</h4><p><b>Overview:</b> We look at a couple ways of interacting with OCaml via UTop. We discuss expressions in OCaml, particularly if-expressions and let-expressions, and begin looking more careful at evaluation.</p><p><b>Keywords:</b> UTop, values, expressions, evaluation, types, syntax, dynamic semantics, static semantics, if-expressions, let-expressions, let-defintions</p><p><b>Required reading:</b></p><ul><li>OCP <a href="https://cs3110.github.io/textbook/chapters/basics/toplevel.html">2.1: The OCaml Toplevel</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/basics/compiling.html">2.2.(1-2): Compiling OCaml Programs</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/basics/expressions.html">2.3: Expressions</a></li></ul><p><b>Additional information:</b></p><ul><li>Homework 0 is due on Thursday by 11:59PM</li><li>The office hours calendar has been updated with locations</li><li>Attend lab this week if you need help setting up your programming environment</li></ul><h4 id="ocaml_intro_ii"><a href="#ocaml_intro_ii" class="anchor"></a>Functions</h4><p><b>Overview:</b> We cover the various ways of defining functions in OCaml, some fundamental and some just convenient. We note the issue of parentheses, which includes a discussion of the <i>right</i> associativity of function types and the <i>left</i> associativity of function application. This is all connected to type inference, a topic that will (likely) come up later in the course</p><p><b>Keywords:</b> recursive functions, anonymous functions, (partial) function application, pipelines, labeled and optional arguments, associativity, type inference</p><p><b>Required reading:</b></p><ul><li>OCP <a href="https://cs3110.github.io/textbook/chapters/basics/functions.html">2.4: Functions</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/basics/printing.html">2.6: Printing</a></li></ul><p><b>Additional information:</b></p><ul><li>Homework 0 is due <i>tonight</i> by 11:59PM</li><li>Homework 1 will be released before the start of lecture</li></ul><h4 id="ocaml_intro_iii"><a href="#ocaml_intro_iii" class="anchor"></a>Unions and Products</h4><p><b>Overview:</b> We examine unions and products as ways of organizing data in OCaml via variants, tuples and records. We also start studying pattern matching more closely and, in particular, what exactly a <i>pattern</i> is.</p><p><b>Keywords:</b> variants, pattern matching, wildcards, tuples, records, accessors, record updates</p><p><b>Required reading:</b></p><ul><li>OCP <a href="https://cs3110.github.io/textbook/chapters/data/variants.html">3.2: Variants</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/data/records_tuples.html">3.4: Records and Tuples</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">3.9.(1-3): Data-Carrying Variants</a></li></ul><p><b>Additional information:</b></p><ul><li>Homework 1 is due on Thursday by 11:59PM</li><li>Discussion this week will provide practice problems for the assignments and the exams</li></ul><h4 id="ocaml_intro_iv"><a href="#ocaml_intro_iv" class="anchor"></a>Lists and IO</h4><p><b>Overview:</b> We look at lists, our first example of a more complex data type, one which can depend on other types (i.e., it is <i>polymorphic</i>). We also discuss the connection between lists and tail recursion. In the reading, we see some useful functions for printing.</p><p><b>Keywords.</b> cons, tail, type constructor, deep pattern matching, unit, printf</p><p><b>Required reading:</b></p><ul><li>OCP <a href="https://cs3110.github.io/textbook/chapters/basics/printing.html">2.6: Printing</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/data/lists.html">3.1: Lists</a></li></ul><p><b>Additional information:</b></p><ul><li>Homework 1 is due <i>tonight</i> by 11:59PM</li><li>Homework 2 will be released before the start of lecture</li></ul><h3 id="ind_types"><a href="#ind_types" class="anchor"></a>Inductive Types</h3><h4 id="ind_types_i"><a href="#ind_types_i" class="anchor"></a>Introduction</h4><p><b>Overview:</b> We cover in more detail algebraic data types (ADTs), in particular recurive ADTs and parametric ADTs. This will get us set up to start discussing things like evaluation strategies and infinite data types.</p><p><b>Required reading:</b> OCP <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">3.9: Algebraic Data Types</a></p><p><b>Keywords:</b> algebraic data types, simple variants, pattern matching, constructors, data-carrying variants, recursive variants, parametric variants, lists, options, results</p><p><b>Additional information:</b></p><ul><li>Homework 2 is due on Thursday by 11:59PM</li></ul><h4 id="ind_types_ii"><a href="#ind_types_ii" class="anchor"></a>Examples</h4><p><b>Overview:</b> We see some examples of more complex algebraic data types like trees, as well as some of their operations.</p><p><b>Required reading:</b></p><ul><li>OCP <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">3.9: Algebraic Data Types</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/data/trees.html">3.11: Example: Trees</a></li></ul><p><b>Keywords:</b> algebraic data types, trees, pre-order, post-order, membership</p><p><b>Additional information:</b></p><ul><li>Homework 2 is due on <i>tonight</i> by 11:59PM</li></ul><h3 id="ho"><a href="#ho" class="anchor"></a>Higher-Order Programming</h3><h4 id="ho_i"><a href="#ho_i" class="anchor"></a>Maps and Filters</h4><p><b>Overview:</b> We introduce the notion of higher-order functions, which can be used to parametrize functions by other functions. We look at two common higher order functions: map and filter.</p><p><b>Required reading:</b></p><ul><li>OCP <a href="https://cs3110.github.io/textbook/chapters/hop/higher_order.html">4.1: Higher-Order Functions</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/hop/map.html">4.2: Map</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/hop/filter.html">4.3: Filter</a></li></ul><p><b>Keywords:</b> higher-order functions, first-class values, functions as function parameters, the abstraction principle, map, filter</p><p><b>Additional information:</b></p><ul><li>This lecture is on Thursday instead of Tuesday because of cancellations due to weather</li><li>Homework 3 is due on Friday by 11:59PM</li></ul><h4 id="ho_ii"><a href="#ho_ii" class="anchor"></a>Folds and Examples</h4><p><b>Overview:</b> We finish our discussion of higher-order functions with folding and the use of higher-order functions for data types other than lists.</p><p><b>Required reading:</b></p><ul><li>OCP <a href="https://cs3110.github.io/textbook/chapters/hop/fold.html">4.4: Fold</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/hop/beyond_lists.html">4.5: Beyond Lists</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/hop/pipelining.html">4.6: Pipelining</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/hop/pipelining.html">4.7: Currying</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/data/options.html">3.7: Options</a></li></ul><p><b>Keywords:</b> fold right, fold left, tail-recursion, associativity, tree map, tree fold</p><p><b>Additional information:</b></p><ul><li>Homework 4 is due on Friday by 11:59PM</li><li>No assignment will be assigned this week</li><li>The midterm is next week</li></ul><h3 id="inter"><a href="#inter" class="anchor"></a>Intermediate OCaml</h3><h4 id="inter_i"><a href="#inter_i" class="anchor"></a>Options, Monads and Modules</h4><p><b>Overview:</b> We discuss very briefly the module system of OCaml and the use of monads.</p><p><b>Required reading:</b></p><ul><li>OCP <a href="https://cs3110.github.io/textbook/chapters/data/options.html">3.7: Options</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/ds/monads.html">8.7: Monads</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/modules/module_systems.html">5.1: Module Systems</a></li><li>OCP <a href="https://cs3110.github.io/textbook/chapters/modules/modules.html">5.2: Modules</a></li></ul><p><b>Keywords:</b> options, monads, modules</p><p><b>Additional information:</b></p><ul><li>The midterm is next week</li><li>A practice midterm has been posted</li></ul><h3 id="grammar"><a href="#grammar" class="anchor"></a>Formal Grammar</h3><h4 id="grammar_i"><a href="#grammar_i" class="anchor"></a>Introduction</h4><p><b>Overview:</b> We introduce formal grammars and BNF specifications.</p><p><b>Keywords:</b> Formal grammar, context-free grammar, BNF specification, nonterminal symbol, terminal symbol, sentential form, sentence, production rule, derivation, recongizing a sentence, generating a sentence, parse tree</p><p><b>Additional information:</b></p><ul><li>Midterm grades will be posted next week</li></ul><h4 id="grammar_ii"><a href="#grammar_ii" class="anchor"></a>Ambiguity</h4><p><b>Overview:</b> We discuss how grammars can be ambiguous, how we might avoid ambiguity, and why we might want to avoid ambiguity.</p><p><b>Keywords:</b> grammatical ambiguity, (reverse) polish notation, parentheses, fixity, associativity, precedence</p><p><b>Additional information:</b></p><ul><li>Homework 5 is due on Friday by 11:59PM</li></ul><h4 id="grammar_iii"><a href="#grammar_iii" class="anchor"></a>Extended BNF and Regular Expressions</h4><p><b>Overview.</b> We introduce syntactic sugar into our BNF specifications to make them easier to define. We also take a brief detour to talk about regular grammars and regular expressions, which capture a weaker but ultimately very useful class of grammars.</p><p><b>Keywords:</b> extended BNF, regular grammars, regular expressions</p><p><b>Additional information:</b></p><ul><li>Homework 6 is assigned, it will not be due until after the break</li><li>Midterm grades have been posted</li></ul><h3 id="parse"><a href="#parse" class="anchor"></a>Parsing</h3><h4 id="parse_i"><a href="#parse_i" class="anchor"></a>Introduction</h4><p><b>Overview:</b> We begin our study of parsing, starting with lexical analysis, and then thinking a bit about the general parsing problem. We will look at an example of recursive descent, a top-down parsing method.</p><p><b>Keywords:</b> parser generators, lexical analysis, lexeme, token, parsing, recursive descent</p><p><b>Supplemental reading:</b> Much of this part of the course is based loosely on the book <i>Concepts of Programming Languages</i> by Robert W. Sebesta (available online without looking too hard, though we don't explicitly condone this...) We diverge from the book a fair amount, but if you want some additional reading on the topics, this source may be useful.</p><ul><li>CPL 4.1: Introduction</li><li>CPL 4.2: Lexical Analysis</li><li>CPL 4.3: The Parsing Problem</li><li>CPL 4.4: Recursive-Descent Parsing</li></ul><p><b>Additional information:</b></p><ul><li>Homework 6 is due on Friday by 11:59PM</li><li>The withdraw deadline for the course is March 29th</li></ul><h4 id="parse_ii"><a href="#parse_ii" class="anchor"></a>General Parsing</h4><p><b>Overview:</b> We reiterate some of the material from last lecture and introduce the notion of Chomsky normal forms.</p><p><b>Keywords:</b> lexical analysis, Chomsky normal forms, context-free grammars</p><p><b>Additional information:</b></p><ul><li>Homework 6 is due on Friday by 11:59PM</li></ul><h4 id="parse_iii"><a href="#parse_iii" class="anchor"></a>Combinators</h4><p><b>Overview:</b> We introduce a high-level functional interface for building up complex parsers. We see many examples, and connect this interface back to our dicussion of EBNF grammars</p><p><b>Keywords:</b> combinator, mapping, sequencing, alternatives, pure, fail, bind, optionals, repetition</p><p><b>Additional information:</b></p><ul><li>Homework 7 is due on Friday by 11:59PM</li><li>This week marks the beginning of the BUGSWU strike, please read the note on Piazza about how this will affect the course</li></ul><h3 id="sem"><a href="#sem" class="anchor"></a>Formal Semantics</h3><h4 id="sem_i"><a href="#sem_i" class="anchor"></a>Operational Semantics</h4><p><b>Overview:</b> We look generally at the notion of semantics, distinguishing between static and dynamic semantics. We introduce configurations and reduction rules as the basis of operational semantics.</p><p><b>Keywords:</b> static semantics, dynamic semantics, denotational semantics, operational semantics, abstract machine, configuration, reduction rule, stack-oriented language</p><p><b>Additional information:</b></p><ul><li>Homework 7 is due on Friday by 11:59PM</li><li>Homework 8 is released on Friday</li></ul><h4 id="sem_ii"><a href="#sem_ii" class="anchor"></a>Applying Rules</h4><p><b>Overview:</b> We look more carefully at the notion of a reduction rule and define the notion of a derivation, which verifies that a reduction holds. We also introduce additional reduction rules to be able to reason about multi-step reductions. We see see general techniques for building derivations of reductions.</p><p><b>Keywords:</b> operational semantics, configuration, abstract machine, reduction rule, derivation, single-step reduction, multi-step reduction</p><p><b>Additional information:</b></p><ul><li>Homework 8 is now due Saturday by 11:59PM</li></ul><h4 id="sem_iii"><a href="#sem_iii" class="anchor"></a>Designing Rules</h4><p><b>Overview:</b> We briefly discuss the design of rules. We then introduce a toy stack language with variables (this will be useful for project 1).</p><p><b>Keywords:</b> Environment, fetching from the environment, updating the environment</p><h3 id="sub"><a href="#sub" class="anchor"></a>Variables and Subprograms</h3><h4 id="sub_i"><a href="#sub_i" class="anchor"></a>Variable Binding and Scoping</h4><p><b>Overview:</b> We discuss the difference between dynamic and lexical scoping. We see some examples of dynamic scoping and hint at the difficulty of lexical scoping in the context of subroutines.</p><p><b>Keywords:</b> environment, scope, mutability, binding, assignment, lexical scoping, dynamic scoping, let-bindings, binding-defined scope, block-defined scope</p><h4 id="sub_ii"><a href="#sub_ii" class="anchor"></a>Parameter Passing</h4><p><b>Overview:</b> We discuss various methods of parameter passing, in particular call-by-name and call-by-value. We see the benefits and downsides of each method.</p><p><b>Keywords:</b> evaluation strategy, call-by-name, call-by-value, the lambda calculus, call-by-reference</p><h4 id="sub_iii"><a href="#sub_iii" class="anchor"></a>Activation Records and Closures</h4><h4 id="sub_iv"><a href="#sub_iv" class="anchor"></a>Substitution Model</h4><h3 id="adv"><a href="#adv" class="anchor"></a>Advanced Topics</h3><h4 id="adv_topic_i"><a href="#adv_topic_i" class="anchor"></a>Compilation</h4><h4 id="adv_topic_ii"><a href="#adv_topic_ii" class="anchor"></a>The Lean Theorem Prover</h4></div></body></html>
