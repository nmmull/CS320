<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>lab10 (Spring-2025.lab10)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../odoc.support/katex.min.css"/><script src="../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">Spring-2025</a> &#x00BB; lab10</nav><header class="odoc-preamble"><h1 id="lab-9:-operational-semantics-worksheet"><a href="#lab-9:-operational-semantics-worksheet" class="anchor"></a>Lab 9: Operational Semantics Worksheet</h1><p>In this course we primarily focus on functional languages, but it's useful to get a sense of how imperative languages work as well. This lab will give us a chance to look at a simple implementation of an imperative language. It will also be an exercise in reverse engineering. Make sure to pull down the changes to the course repo to get access to the <code>lab10</code> starter code.</p></header><nav class="odoc-toc"><ul><li><a href="#reading-the-lexer-and-parser">Reading the Lexer and Parser</a></li><li><a href="#small-step-semantics">Small-Step Semantics</a></li><li><a href="#implementing-dynamic-scoping">Implementing Dynamic Scoping</a></li><li><a href="#challenge:-big-step-semantics">Challenge: Big Step Semantics</a></li></ul></nav><div class="odoc-content"><h2 id="reading-the-lexer-and-parser"><a href="#reading-the-lexer-and-parser" class="anchor"></a>Reading the Lexer and Parser</h2><p>Take a look at the the files <code>lib/lexer.mll</code> and <code>lib/parser.mly</code>. Given the code there, what is the grammar of the our programming language? (<i>Hint.</i> It's a fragment of bash script. You may also be able to glean it from the semantics below).</p><p>Based on the lexer, what are the allowed variable names and numbers?</p><h2 id="small-step-semantics"><a href="#small-step-semantics" class="anchor"></a>Small-Step Semantics</h2><p>Consider the following small-step semantics</p><div><pre class="odoc-katex-math display">\frac{}
{\langle \ \mathcal E \ , \ X\texttt{=}n\texttt{;}Q \ \rangle
\longrightarrow
\langle \ \mathcal E[x \mapsto n] \ , \ Q \ \rangle
}
\text{ (assign-num)}
</pre></div><div><pre class="odoc-katex-math display">\frac
{(Y \mapsto n) \in \mathcal E \qquad n \text{ is a number}}
{
\langle \ \mathcal E \ , \ X\texttt{=\$}Y\texttt{;}Q \ \rangle
\longrightarrow
\langle \ \mathcal E[X \mapsto v] \ , \ Q \ \rangle
}
\text{ (assign-var)}
</pre></div><div><pre class="odoc-katex-math display">\frac
{}
{\langle \ \mathcal E \ , \ F\texttt{()\{}P\texttt{\};}Q \ \rangle
\longrightarrow
\langle \ \mathcal E[F \mapsto P] \ , \ Q \ \rangle
}
\text{ (fun-def)}
</pre></div><div><pre class="odoc-katex-math display">\frac
{(F \mapsto P) \in \mathcal E \qquad P \text{ is a program}}
{
\langle \ \mathcal E \ , \ F\texttt{;}Q \ \rangle
\longrightarrow
\langle \ \mathcal E \ , \ P \ Q \ \rangle
}
\text{ (fun-call)}
</pre></div><p>Write a sequence of small-step reductions for the following program</p><pre class="language-text"><code>F(){Y=$X;};G(){X=0;};G;F;X=1;F;</code></pre><h2 id="implementing-dynamic-scoping"><a href="#implementing-dynamic-scoping" class="anchor"></a>Implementing Dynamic Scoping</h2><p>As mentioned in lecture, dynamic scoping is a fair amount easier to implement than lexical scoping because function calls are list concatentations. In the file <code>lib/eval.ml</code> implement the function <code>eval_step</code> so that <code>eval_step (env, p)</code> is <code>Some (env', p')</code> if <code>(env, p)</code> reduces in a single step to <code>(env', p')</code> according to the above rules. It should be <code>None</code> otherwise.</p><p>If you finish this, you should be able to run the <code>interp</code> function and compare your solution to the previous problem with the output. (If you don't have time, the solution is included in <code>lib/lab10_solution.ml</code>)</p><p>Also note that all programs accepted by this interpreter are valid bash scripts. If you type the program into your terminal and then type <code>echo $X</code> for any variable <code>X</code> bound to a number, you should see the same value as what <code>X</code> is bound to in the final environment according to our interpreter.</p><h2 id="challenge:-big-step-semantics"><a href="#challenge:-big-step-semantics" class="anchor"></a>Challenge: Big Step Semantics</h2><p>It's often more natural to implement an interpreter with big-step semantics (this is why it's also called <i>natural</i> semantics). However, langauges are often presented using small-step semantics because it's better for proving things about the language. Give an equivalent big-step semantics for the above rules and implement them.</p></div></body></html>
