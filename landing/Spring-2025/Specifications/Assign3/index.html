<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign3 (Spring-2025.Specifications.Assign3)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign3</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign3</span></code></h1><p>This assignment is due on <b>Thursday 2/13 by 8:00PM</b>. You should put all of your solutions in a file called <code>assign3/lib/assign3.ml</code>. See the file <code>test/test_assign3.ml</code> for example behavior of each function.</p></header><nav class="odoc-toc"><ul><li><a href="#programming">Programming</a><ul><li><a href="#practice-problems-(ungraded)">Practice Problems (Ungraded)</a></li><li><a href="#tree-conversion">Tree Conversion</a></li><li><a href="#tail-recursive-fibonacci-variant">Tail-Recursive Fibonacci Variant</a></li><li><a href="#file-trees">File Trees</a></li><li><a href="#expressions-(with-variables)">Expressions (with Variables)</a></li></ul></li><li><a href="#written">Written</a><ul><li><a href="#typing-derivation-to-english">Typing Derivation to English</a></li><li><a href="#typing-derivation">Typing Derivation</a></li><li><a href="#semantic-derivation">Semantic Derivation</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="programming"><a href="#programming" class="anchor"></a>Programming</h2><h3 id="practice-problems-(ungraded)"><a href="#practice-problems-(ungraded)" class="anchor"></a>Practice Problems (Ungraded)</h3><p>These problems come from a list of <a href="https://ocaml.org/exercises">Exercises</a> on OCaml's webpage. We won't grade these (the solutions are given with the problem statements).</p><ul><li><a href="https://ocaml.org/exercises#56">Symmetric Binary Trees</a></li><li><a href="https://ocaml.org/exercises#57">Binary Search Trees</a></li><li><a href="https://ocaml.org/exercises#62B">Collect the Nodes at a Given Level in a List</a></li><li><a href="https://ocaml.org/exercises#68">Preorder and Inorder Sequences of Binary Trees</a></li><li><a href="https://ocaml.org/exercises#70B">Count the Nodes of a Multiway Tree</a></li></ul><p>Note that a we call a multiway tree a <em>nonempty tree</em> (<code>ntree</code>) in <code>stdlib320</code>.</p><h3 id="tree-conversion"><a href="#tree-conversion" class="anchor"></a>Tree Conversion</h3><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a tree</span></span><span> = </span></code><ol><li id="type-tree.Leaf" class="def variant constructor anchored"><a href="#type-tree.Leaf" class="anchor"></a><code><span>| </span><span><span class="constructor">Leaf</span></span></code></li><li id="type-tree.Node2" class="def variant constructor anchored"><a href="#type-tree.Node2" class="anchor"></a><code><span>| </span><span><span class="constructor">Node2</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-tree">tree</a></span> * <span><span class="type-var">'a</span> <a href="#type-tree">tree</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ntree_of_tree"><a href="#val-ntree_of_tree" class="anchor"></a><code><span><span class="keyword">val</span> ntree_of_tree : <span><span><span class="type-var">'a</span> <a href="#type-tree">tree</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>ntree_of_tree</code> so that <code>ntree_of_tree t</code> is <code>None</code> if <code>t</code> is empty (i.e., it's just a leaf) and, otherwise, is <code>Some t'</code> where <code>t'</code> is a representation of <code>t</code> as a nonempty (i.e., multiway) tree.</p></div></div><h3 id="tail-recursive-fibonacci-variant"><a href="#tail-recursive-fibonacci-variant" class="anchor"></a>Tail-Recursive Fibonacci Variant</h3><p>The standard Fibonacci sequence is define by the following recurrence relation.</p><div><pre class="odoc-katex-math display">    \begin{align*}
    F_0 &amp;= 1 \\
    F_1 &amp;= 1 \\
    F_n &amp;= F_{n - 1} + F_{n - 2}
    \end{align*}
    </pre></div><p>We will update this definition so that we have <em>three</em> initial values (which are parameters of the function below):</p><div><pre class="odoc-katex-math display">    \begin{align*}
    G_0 &amp;= a \\
    G_1 &amp;= b \\
    G_2 &amp;= c \\
    G_n &amp;= G_{n - 1} + G_{n - 2} + G_{n - 3}
    \end{align*}
    </pre></div><div class="odoc-spec"><div class="spec value anchored" id="val-fib3_tail"><a href="#val-fib3_tail" class="anchor"></a><code><span><span class="keyword">val</span> fib3_tail : <span><span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Implement the function <code>fib3_tail</code> so that <code>fib (a, b, c) n</code> is the <code class="odoc-katex-math">G_n</code> as defined above. Your solution <b>must</b> be tail recursive.</p></div></div><h3 id="file-trees"><a href="#file-trees" class="anchor"></a>File Trees</h3><p>We can think of a file system as tree of directories and files. In this problem we will be converting a list of files paths into an <code>ntree</code>. For example, given the paths:</p><pre class="language-text"><code>dir1/file1
dir1/file2
dir2/dir3/file1
dir2/file1</code></pre><p>we can construct the nonempty tree <code>file_tree &quot;.&quot; paths</code>:</p><pre class="language-ocaml"><code>Node (&quot;.&quot;, [
  Node (&quot;dir1&quot;, [
    Node (&quot;file1&quot;, []);
    Node (&quot;file2&quot;, []);
  ]);
  Node (&quot;dir2&quot;, [
    Node (&quot;dir3&quot;, [
      Node (&quot;file1&quot;, []);
    ]);
    Node (&quot;file1&quot;, []);
  ]);
])</code></pre><p>which we can then print with <code>NTree.print (fun x -&gt; x)</code>:</p><pre class="language-text"><code>.
├──dir1
│  ├──file1
│  └──file2
└──dir2
   ├──dir3
   │  └──file1
   └──file1</code></pre><p>In this representation, a file is a leaf node, i.e., a node with no children. We will take a very relaxed definition of a file name: <i>a file name can be any sequence of characters not including <code>'/'</code>.</i> This means that every string is a valid path (even <code>&quot;foo/bar///baz&quot;</code>. In particular <code>&quot;&quot;</code> represents the file with the empty string as its name (this is not realistic, but it make the problem easier). This definition allows us to use the function <code>split_on_char</code> from Lab 3 to help us split a path into its individual components.</p><div class="odoc-spec"><div class="spec value anchored" id="val-file_tree"><a href="#val-file_tree" class="anchor"></a><code><span><span class="keyword">val</span> file_tree : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span></span></code></div><div class="spec-doc"><p>Implement the function <code>file_tree</code> so that <code>file_tree root
    file_paths</code> is an <code>ntree</code> consisting of all the paths given in <code>file_paths</code>, and whose root value is <code>root</code>. It is possible for <code>file_paths</code> to contain duplicates, but if it does not, there should be a one-to-one correspondence between paths from the root to the leaves of the tree and paths in <code>file_paths</code>.</p><p>To aid you, we'll provide the following function:</p><pre class="language-ocaml"><code>let rec files_of_tree (Node (root, children)) =
  let rec expand children =
    match children with
    | [] -&gt; []
    | c :: cs -&gt; files_of_tree c @ expand cs
  in
  let rec add_root fs =
    match fs with
    | [] -&gt; []
    | f :: fs -&gt; (root ^ &quot;/&quot; ^ f) :: add_root fs
  in
  if children = []
  then [root]
  else add_root (expand children)</code></pre><p>If you apply this function to the output of <code>file_tree</code>, you should get back the same list of file paths (potentially in a different order) but with the root directory append to the front of each one.</p></div></div><h3 id="expressions-(with-variables)"><a href="#expressions-(with-variables)" class="anchor"></a>Expressions (with Variables)</h3><p>In lecture, we saw a representation of arithmetic expressions as values of an ADT. In this problem we'll be working with a similar ADT, representing arithmetic expressions (over addition and multiplication only) with variables.</p><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.Num" class="def variant constructor anchored"><a href="#type-expr.Num" class="anchor"></a><code><span>| </span><span><span class="constructor">Num</span> <span class="keyword">of</span> int</span></code></li><li id="type-expr.Var" class="def variant constructor anchored"><a href="#type-expr.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> string</span></code></li><li id="type-expr.Add" class="def variant constructor anchored"><a href="#type-expr.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.Mul" class="def variant constructor anchored"><a href="#type-expr.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subst"><a href="#val-subst" class="anchor"></a><code><span><span class="keyword">val</span> subst : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-expr">expr</a></span></code></div><div class="spec-doc"><p>Implement the function <code>subst</code> so that <code>subst e1 x e2</code> is the result of replacing every instance of the variable identified by <code>x</code> in <code>e2</code> with the expression <code>e1</code>. In mathematical notation, this would be <code class="odoc-katex-math">[e_1 / x] e_2</code>. So, for example, we would have that <code class="odoc-katex-math">[y + 4 / z](z * 3) = (y + 4) * 3</code>.</p><p><i>Note:</i> We've mentioned that substitution is tricky to implement correctly. This is <em>not</em> the case for simple arithmetic expressions. In this case, substitution is exactly replacement of variables, no tricky cases.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_expr"><a href="#val-string_of_expr" class="anchor"></a><code><span><span class="keyword">val</span> string_of_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Implement the function <code>string_of_expr</code> so that <code>string_of_expr e</code> is a string representation of <code>e</code> according to the following rules.</p><ul><li>Every operator is surrounded by exactly one space. There is no other whitespace in the string.</li><li>Multiplication has higher precedence than addition. This means that the expression <code>Mul (Num 2, Add (Num 3, Num 4))</code> should be represented by the string <code>&quot;2 * (3 + 4)&quot;</code> and not <code>&quot;2 * 3 + 4&quot;</code>.</li><li>Sequences of the same operator should not have parentheses. For example, <code>Add (Num 2, Add (Num 3, Num 4))</code> should be represented by the string <code>&quot;2 + 3 + 4&quot;</code> and not <code>&quot;(2 + 3) + 4&quot;</code> or <code>&quot;2 + (3 + 4)&quot;</code>.</li><li>Parentheses should be included only when necessary for disambiguation. For example, <code>Add (Mul (Num 2, Num 3), Num 4)</code> should be represented by the string <code>&quot;2 * 3 + 4&quot;</code> and not <code>&quot;(2 * 3) + 4&quot;</code></li><li>A negative number should be surrounded by parentheses <em>unless</em> it is the first number of a (possibly empty) sequence of operations at the top-level, or within parentheses. For example <code>Add (Num (-2), Add (Num (-3), Num 4))</code> should be represented as the string <code>&quot;-2 + (-3) + 4&quot;</code> whereas <code>Mul (Num (-2), Add (Num (-3), Num 4))</code> should be represented by the string <code>&quot;-2 * (-3 + 4)&quot;</code>. Note that <code>-3</code> is not surrounded by parentheses in this last example.</li></ul></div></div><h2 id="written"><a href="#written" class="anchor"></a>Written</h2><p>All of the problems in this section are based on the inferences rules we've given in class, compiled <a href="https://nmmull.github.io/PL-at-BU/320Caml/notes.html">here</a>.</p><h3 id="typing-derivation-to-english"><a href="#typing-derivation-to-english" class="anchor"></a>Typing Derivation to English</h3><pre class="language-text"><code>                               ──────────────────────(iL) ──────────────────────(intLit)
                               {f:int→bool} ⊢ 2 : int    {f:int→bool} ⊢ 3 : int
─────────────────────────(var) ────────────────────────────────────────────────(addInt)
{f:int→bool} ⊢ f:int→bool                 {f:int→bool} ⊢ 2+3 : int
───────────────────────────────────────────────────────────────────(app)
                  {f:int→bool} ⊢ f (2+3) : bool</code></pre><p>Write an English argument which expresses the same thing as the derivation above. <i>Note.</i> It's very subjective what constitutes <em>enough</em> detail. You'll be graded primarily on effort, please just be as descriptive as you can, using your best judgment.</p><h3 id="typing-derivation"><a href="#typing-derivation" class="anchor"></a>Typing Derivation</h3><div><pre class="odoc-katex-math display">   \{ \texttt{f} : \texttt{int -&gt; bool} \} \vdash \texttt{(if f 2 then (fun x -&gt; true) else f) 3} : \texttt{bool}
   </pre></div><p>Give a derivation of the above typing judgment. <i>Note.</i> This will take a bit of space. Please write as neatly as possible.</p><h3 id="semantic-derivation"><a href="#semantic-derivation" class="anchor"></a>Semantic Derivation</h3><div><pre class="odoc-katex-math display">   \texttt{let x = true in 3 + (if false || x then 2 else 1)} \Downarrow 5
   </pre></div><p>Give a derivation of the above semantic judgment.</p></div></body></html>
