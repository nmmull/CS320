<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign5 (Spring-2025.Specifications.Assign5)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign5</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign5</span></code></h1><p>This assignment is due on <b>Thursday 3/6 by 8:00PM</b>. You should put all of your solutions in <code>assign5/lib/assign5.ml</code>. See the file <code>test/test_assign5.ml</code> for example behavior of each function.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#programming">Programming</a><ul><li><a href="#practice-problems-(ungraded)">Practice Problems (Ungraded)</a></li><li><a href="#evaluation-with-errors">Evaluation with Errors</a></li><li><a href="#exception-handling">Exception Handling</a></li><li><a href="#deques">Deques</a></li><li><a href="#mapping-keys">Mapping Keys</a></li></ul></li><li><a href="#written">Written</a></li><li><a href="#partial-derivation">Partial Derivation</a></li><li><a href="#typing-derivation">Typing Derivation</a></li><li><a href="#semantic-derivation">Semantic Derivation</a></li></ul></nav></div><div class="odoc-content"><h2 id="programming"><a href="#programming" class="anchor"></a>Programming</h2><h3 id="practice-problems-(ungraded)"><a href="#practice-problems-(ungraded)" class="anchor"></a>Practice Problems (Ungraded)</h3><p>These problems come the textbook <a href="https://cs3110.github.io/textbook/cover.html">OCP</a>.</p><ul><li><a href="https://cs3110.github.io/textbook/chapters/data/exercises.html#:~:text=Exercise:%20powerset">powerset</a></li><li><a href="https://cs3110.github.io/textbook/chapters/data/exercises.html#:~:text=Exercise:%20safe%20hd%20and%20tl">safe hd and tl</a></li><li><a href="https://cs3110.github.io/textbook/chapters/data/exercises.html#:~:text=Exercise:%20list%20max%20exn%20string">list max exn string</a></li><li><a href="https://cs3110.github.io/textbook/chapters/data/exercises.html#:~:text=Exercise:%20list%20max%20exn%20ounit">list max exn ounit</a></li><li><a href="https://cs3110.github.io/textbook/chapters/hop/exercises.html#:~:text=Exercise:%20account%20balance">account balance</a></li><li><a href="https://cs3110.github.io/textbook/chapters/hop/exercises.html#:~:text=Exercise:%20valid%20matrix">valid matrix</a></li><li><a href="https://cs3110.github.io/textbook/chapters/modules/exercises.html#:~:text=Exercise:%20fraction">fraction</a></li></ul><h3 id="evaluation-with-errors"><a href="#evaluation-with-errors" class="anchor"></a>Evaluation with Errors</h3><p>In this problem we'll be looking at a common pattern for representing expressions with metadata. We'll look at arithmetic expressions with addition, subtraction, multiplication, division, and exponentiation.</p><p>Expressions are defined mutually recursively so that all expressions, including subexpressions, carry metadata of a given type parameter.</p><div class="odoc-spec"><div class="spec type anchored" id="type-op"><a href="#type-op" class="anchor"></a><code><span><span class="keyword">type</span> op</span><span> = </span></code><ol><li id="type-op.Add" class="def variant constructor anchored"><a href="#type-op.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span></span></code></li><li id="type-op.Sub" class="def variant constructor anchored"><a href="#type-op.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span></span></code></li><li id="type-op.Mul" class="def variant constructor anchored"><a href="#type-op.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span></span></code></li><li id="type-op.Div" class="def variant constructor anchored"><a href="#type-op.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code></li><li id="type-op.Pow" class="def variant constructor anchored"><a href="#type-op.Pow" class="anchor"></a><code><span>| </span><span><span class="constructor">Pow</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a expr</span></span><span> = </span><span>{</span></code><ol><li id="type-expr.expr" class="def record field anchored"><a href="#type-expr.expr" class="anchor"></a><code><span>expr : <span><span class="type-var">'a</span> <a href="#type-_expr">_expr</a></span>;</span></code></li><li id="type-expr.meta" class="def record field anchored"><a href="#type-expr.meta" class="anchor"></a><code><span>meta : <span class="type-var">'a</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-_expr"><a href="#type-_expr" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a _expr</span></span><span> = </span></code><ol><li id="type-_expr.Num" class="def variant constructor anchored"><a href="#type-_expr.Num" class="anchor"></a><code><span>| </span><span><span class="constructor">Num</span> <span class="keyword">of</span> int</span></code></li><li id="type-_expr.Op" class="def variant constructor anchored"><a href="#type-_expr.Op" class="anchor"></a><code><span>| </span><span><span class="constructor">Op</span> <span class="keyword">of</span> <a href="#type-op">op</a> * <span><span class="type-var">'a</span> <a href="#type-expr">expr</a></span> * <span><span class="type-var">'a</span> <a href="#type-expr">expr</a></span></span></code></li></ol></div></div><p>Note the very cool use of the <code>and</code> keyword, which allows use to define mutually recursive types (and functions). We'll be implementing an evaluator for expressions with metadata, and for which errors cases are handled using the <code>result</code> type.</p><p>There are two kinds of errors that could occur when evaluating an arithmetic expression of this form:</p><ul><li>The second argument of a division evaluates to zero, in which case evaluation should result in a <code>DivByZero</code> error.</li><li>The second argument of an exponentiation evaluates to a negative number, in which case evaluation should result in a <code>NegExp</code> error.</li></ul><p>Like expressions, errors carry metadata. As an example, we can imagine expressions and errors carrying data describing the line number at which an expression/error occurs, so that we can present a better error message to the user.</p><div class="odoc-spec"><div class="spec type anchored" id="type-error_kind"><a href="#type-error_kind" class="anchor"></a><code><span><span class="keyword">type</span> error_kind</span><span> = </span></code><ol><li id="type-error_kind.DivByZero" class="def variant constructor anchored"><a href="#type-error_kind.DivByZero" class="anchor"></a><code><span>| </span><span><span class="constructor">DivByZero</span></span></code></li><li id="type-error_kind.NegExp" class="def variant constructor anchored"><a href="#type-error_kind.NegExp" class="anchor"></a><code><span>| </span><span><span class="constructor">NegExp</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-error"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a error</span></span><span> = </span><span>{</span></code><ol><li id="type-error.error" class="def record field anchored"><a href="#type-error.error" class="anchor"></a><code><span>error : <a href="#type-error_kind">error_kind</a>;</span></code></li><li id="type-error.meta" class="def record field anchored"><a href="#type-error.meta" class="anchor"></a><code><span>meta : <span class="type-var">'a</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span><span class="keyword">val</span> eval : <span><span><span class="type-var">'a</span> <a href="#type-expr">expr</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int, <span><span class="type-var">'a</span> <a href="#type-error">error</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Implement the function <code>eval</code> so that <code>eval e</code> is <code>Ok n</code> if <code>e</code> has no division-by-zero or negative-exponent errors and has the value <code>n</code>. The expression <code>eval e</code> should be <code>Error {error;meta}</code> otherwise, where <code>error</code> describes the kind of error in <code>e</code> and <code>meta</code> is the metadata of the <b>leftmost division expression whose right-hand side evaluates to zero, or the leftmost exponentiation expression whose right-hand side evaluates to a negative number</b>.</p><p>You can implement this function however you'd like but we recommend <em>trying</em> to use the monadic <code>let*</code> notation, since the solution done in this way is quite clean.</p><p>We've included the function <code>guard</code>, which may be helpful. It can be used as follows:</p><pre class="language-ocaml"><code>let ( let* ) = Result.bind

let guard b error = if b then Error error else Ok ()

let check x_res error =
  let* x = x_res in
  let* _ = guard (x = 0) error in
  Ok x

let _ = assert (check (Ok 2) () = Ok 2)
let _ = assert (check (Error ()) () = Error ())
let _ = assert (check (Ok 0) () = Error ())</code></pre></div></div><h3 id="exception-handling"><a href="#exception-handling" class="anchor"></a>Exception Handling</h3><div class="odoc-spec"><div class="spec exception anchored" id="exception-ListTooShort"><a href="#exception-ListTooShort" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">ListTooShort</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-InvalidArg"><a href="#exception-InvalidArg" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">InvalidArg</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefix"><a href="#val-prefix" class="anchor"></a><code><span><span class="keyword">val</span> prefix : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>prefix</code> so that <code>prefix k l</code> is the list consisting of the first <code>k</code> elements of <code>l</code>. It should raise a <code>ListTooShort</code> exception if <code>k</code> is greater than the length of <code>l</code>, and should raise an <code>InvalidArg</code> exception if <code>k</code> is negative.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-prefix_error"><a href="#type-prefix_error" class="anchor"></a><code><span><span class="keyword">type</span> prefix_error</span><span> = </span></code><ol><li id="type-prefix_error.ListTooShort" class="def variant constructor anchored"><a href="#type-prefix_error.ListTooShort" class="anchor"></a><code><span>| </span><span><span class="constructor">ListTooShort</span></span></code></li><li id="type-prefix_error.InvalidArg" class="def variant constructor anchored"><a href="#type-prefix_error.InvalidArg" class="anchor"></a><code><span>| </span><span><span class="constructor">InvalidArg</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefix_res"><a href="#val-prefix_res" class="anchor"></a><code><span><span class="keyword">val</span> prefix_res : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> list</span>, <a href="#type-prefix_error">prefix_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Implement the function <code>prefix_res</code> so that <code>prefix k l</code> is <code>Ok p</code> where <code>p</code> is the list consisting of the first <code>k</code> elements of <code>l</code>, given <code>k</code> is at most the length of <code>l</code> and <code>k</code> is nonnegative. It should return an error otherwise (I'll let you determine what kind of error). <i>Hint:</i> Don't reimplement the function.</p></div></div><h3 id="deques"><a href="#deques" class="anchor"></a>Deques</h3><p>A <em>double-ended queue</em>, or dequeue, is a list-like data structure for which is possible to pop from and push to both the front and back. For our purposes a dequeue implements the following signature.</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-DEQUEUE"><a href="#module-type-DEQUEUE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-DEQUEUE/index.html">DEQUEUE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-ListDequeue"><a href="#module-ListDequeue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ListDequeue/index.html">ListDequeue</a></span><span> : <a href="module-type-DEQUEUE/index.html">DEQUEUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-DEQUEUE/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> list</span></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-DoubleListDequeue"><a href="#module-DoubleListDequeue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="DoubleListDequeue/index.html">DoubleListDequeue</a></span><span> : <a href="module-type-DEQUEUE/index.html">DEQUEUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-DEQUEUE/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></span></code></div></div><p>You need to implement two modules with this signature.</p><ul><li><code>ListDequeue</code>, which takes <code>t</code> to be <code>'a list</code>, and is implemented in the expected way. For this implementation <code>push_back</code> and <code>pop_back</code> will be inefficient.</li><li><code>DoubleListDequeue</code>, which takes <code>t</code> to be a <code>'a list * 'a list</code>.</li></ul><p>For the <code>DoubleListDequeue</code> implementation, we keep track of a <code>front</code> and <code>back</code> list, which we can pop from and push to. This means the the <code>back</code> list holds elements in <em>reverse</em>. In the case that the <code>front</code> list is empty when <code>pop_front</code> is called, the <code>front</code> and <code>back</code> list should be <em>balanced</em>. This means <code>front</code> and <code>back</code> after the call should have the property that</p><pre class="language-ocaml"><code>List.length back - List.length front &lt;= 1</code></pre><p>The same is true for a call to <code>pop_back</code>, the roles of <code>front</code> and <code>back</code> reversed. For example:</p><pre class="language-text"><code>front: []                     front: [1;2;3;4;5;6]
 back: [5;4;3;2;1]             back: []

â‡“ pop_front                   â‡“ pop_back

front: [2;3]                  front: [1;2;3]
 back: [5;4]                   back: [5;4]</code></pre><h3 id="mapping-keys"><a href="#mapping-keys" class="anchor"></a>Mapping Keys</h3><div class="odoc-spec"><div class="spec module anchored" id="module-StringMap"><a href="#module-StringMap" class="anchor"></a><code><span><span class="keyword">module</span> StringMap</span><span> : <span class="xref-unresolved">Stdlib</span>.Map.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">key</span> = string</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-IntMap"><a href="#module-IntMap" class="anchor"></a><code><span><span class="keyword">module</span> IntMap</span><span> : <span class="xref-unresolved">Stdlib</span>.Map.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">key</span> = int</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-StringSet"><a href="#module-StringSet" class="anchor"></a><code><span><span class="keyword">module</span> StringSet</span><span> : <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">elt</span> = string</span></span></code></div></div><p>In the second half of the course, we'll make use of maps and sets, which are implemented in OCaml using <em>module functors</em>. In the case of maps, we create a module for the type of we want to use for keys. For example, we use <code>Map.Make</code> to create structures for maps with a given type of key, e.g., <code>StringMap</code> and <code>IntMap</code> for maps with <code>string</code> keys and <code>int</code> keys, respectively. In the case of sets, we use <code>Set.Make</code> to create structures for sets with a given type of element.</p><div class="odoc-spec"><div class="spec value anchored" id="val-flip_keys_and_values"><a href="#val-flip_keys_and_values" class="anchor"></a><code><span><span class="keyword">val</span> flip_keys_and_values : <span><span>int <span class="xref-unresolved">StringMap</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">StringSet</span>.t <span class="xref-unresolved">IntMap</span>.t</span></span></code></div><div class="spec-doc"><p>Implement the function <code>flip_keys_and_values</code> so that <code>flip_keys_and_values m</code> is the map <code>m'</code> gotten by making the value of <code>m</code> into keys. The value associated with the key <code>v</code> in <code>m'</code> is the set of keys in <code>m</code> which map to the value <code>v</code>.</p><p>This function will require looking in the the OCaml standard library (not <code>stdlib320</code>) on <a href="https://ocaml.org/manual/5.3/api/Map.S.html">Maps</a> and <a href="https://ocaml.org/manual/5.3/api/Set.S.html">Sets</a>.</p></div></div><h2 id="written"><a href="#written" class="anchor"></a>Written</h2><h2 id="partial-derivation"><a href="#partial-derivation" class="anchor"></a>Partial Derivation</h2><p>Not all judgments are derivable, but it's possible to write <em>partial</em> derivations of underivable judgments. These partial derivations can give us insight into why we get certain type errors when type-checking.</p><p>Formally, a typing derivation is <i>partial</i> if its leaves are not necessarily axioms. A partial derivation is <i>maximal</i> if every leaf of the derivation is either an axiom or a judgment which cannot be derived by any rule in our specification from any judgments.</p><p>Give maximal partial derivations of the following typing judgments.</p><div><pre class="odoc-katex-math display">    \varnothing \vdash \texttt{if true then 1 + 3 else x / false} : \texttt{int}
    </pre></div><div><pre class="odoc-katex-math display">    \varnothing \vdash \texttt{if true then 1 + 3 else false / x} : \texttt{int}
    </pre></div><p>In addition, write down the type error which OCaml gives you when trying to type-check each expression. What does the type-error tell you about the order in which OCaml type-checks sub-expressions?</p><h2 id="typing-derivation"><a href="#typing-derivation" class="anchor"></a>Typing Derivation</h2><p>So far, we haven't introduced any rules for typing recursive functions. Here's such a rule.</p><div><pre class="odoc-katex-math display">    \frac
    {\Gamma, f : \tau \to \tau_1, x : \tau \vdash e_1 : \tau_1
     \qquad
     \Gamma, f : \tau \to \tau_1 \vdash e_2 : \tau_2
    }
    {\Gamma \vdash \texttt{let rec} \ f \ x \ \texttt{=} \ e_1 \ \texttt{in} \ e_2 : \tau_2}
    </pre></div><p>Note that this rule puts <code class="odoc-katex-math">f</code> into the context when determining the type of <code class="odoc-katex-math">e_1</code>, the <em>body</em> of <code class="odoc-katex-math">f</code>, which means that <code class="odoc-katex-math">f</code> can appear in its own body (and, hence, may be recursive). Using this rule, give a derivation of the following typing judgment.</p><div><pre class="odoc-katex-math display">    \varnothing \vdash \texttt{let rec sum l = match l with | [] -&gt; 0 | h :: t -&gt; h + sum t in sum} : \texttt{int list â†’ int}
    </pre></div><p>This will be a somewhat wide derivation. You may use arrows as we've done in lecture to make the derivation less wide, but please make sure your solution is very clear.</p><h2 id="semantic-derivation"><a href="#semantic-derivation" class="anchor"></a>Semantic Derivation</h2><div><pre class="odoc-katex-math display">    \texttt{match 1 :: 2 :: [] with | [] -&gt; true | h :: t -&gt; false} \Downarrow \bot
    </pre></div><p>Give a derivation of the above semantic judgment.</p></div></body></html>
