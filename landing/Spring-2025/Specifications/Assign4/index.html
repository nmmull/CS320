<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign4 (Spring-2025.Specifications.Assign4)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign4</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign4</span></code></h1><p>This assignment is due on <b>Thursday 2/20 by 8:00PM</b>. You should put all of your solutions in <code>assign4/lib/assign4.ml</code>. See the file <code>test/test_assign4.ml</code> for example behavior of each function.</p></header><nav class="odoc-toc"><ul><li><a href="#programming">Programming</a><ul><li><a href="#practice-problems-(ungraded)">Practice Problems (Ungraded)</a></li><li><a href="#basic-higher-order-functions">Basic Higher Order Functions</a></li><li><a href="#tree-filtering">Tree Filtering</a></li><li><a href="#random-walks">Random Walks</a></li></ul></li><li><a href="#written">Written</a><ul><li><a href="#an-ocaml-puzzle">An OCaml Puzzle</a></li><li><a href="#typing-derivation">Typing Derivation</a></li><li><a href="#semantic-derivation">Semantic Derivation</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="programming"><a href="#programming" class="anchor"></a>Programming</h2><h3 id="practice-problems-(ungraded)"><a href="#practice-problems-(ungraded)" class="anchor"></a>Practice Problems (Ungraded)</h3><p>These problems come from a list of <a href="https://ocaml.org/exercises">Exercises</a> on OCaml's webpage. We won't grade these (the solutions are given with the problem statements).</p><ul><li><a href="https://ocaml.org/exercises#15">Replicate the Elements of a List a Given Number of Times</a></li><li><a href="https://ocaml.org/exercises#16">Drop Every N'th Element From a List</a></li><li><a href="https://ocaml.org/exercises#22">Create a List Containing All Integers Within a Given Range</a></li></ul><p>Where possible, try to use higher-order functions, like <code>map</code> and <code>fold_left</code>.</p><h3 id="basic-higher-order-functions"><a href="#basic-higher-order-functions" class="anchor"></a>Basic Higher Order Functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-curry"><a href="#val-curry" class="anchor"></a><code><span><span class="keyword">val</span> curry : <span><span>(<span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p>Implement the function <code>curry</code> which converts a &quot;multi-argument&quot; function (i.e., a function which takes a tuple as an argument) into nested single-argument functions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uncurry"><a href="#val-uncurry" class="anchor"></a><code><span><span class="keyword">val</span> uncurry : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p>Implement the function <code>uncurry</code>, which is the inverse of <code>curry</code>, i.e., it converts a Curried two-argument function into a function which take a tuple as an argument.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>filter_map</code> so that <code>filter_map p l</code> is the result of applying <code>p</code> to every element of <code>l</code>, filtering out the <code>None</code> elements, and keeping only the arguments to the <code>Some</code> elements.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_list"><a href="#val-split_list" class="anchor"></a><code><span><span class="keyword">val</span> split_list : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>split_list</code> so that <code>split_list l</code> is a pair of lists <code>(lefts, rights)</code> where <code>lefts</code> consists of the first elements of every pair in <code>l</code> (in order) and <code>rights</code> consists of the second elements of every pair in <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_tree"><a href="#val-split_tree" class="anchor"></a><code><span><span class="keyword">val</span> split_tree : 
  <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span> * <span><span class="type-var">'b</span> <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span></span></code></div><div class="spec-doc"><p>Implement the function <code>split_tree</code> so that <code>split_tree t</code> constructs two trees of the same structure as <code>t</code>, one with the left element of the tuple in each node of <code>t</code>, and one with the right element of the tuple in each node.</p></div></div><h3 id="tree-filtering"><a href="#tree-filtering" class="anchor"></a>Tree Filtering</h3><p>Defining filters on trees is a bit more complicated than on lists because we have to determine what structure should be maintained if the value at a node is removed. One way of defining filters on tree is to <em>promote</em> the leftmost child of a node that is filtered out by the given predicate.</p><div class="odoc-spec"><div class="spec value anchored" id="val-tree_filter"><a href="#val-tree_filter" class="anchor"></a><code><span><span class="keyword">val</span> tree_filter : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>tree_filter</code> so that <code>tree_filter p t</code> is the result of keeping nodes in <code>t</code> according to the following rules:</p><ul><li>If the value at a node satisfies <code>p</code>, then it should be left as it is and it's children should be recursively filtered</li><li>If a node does not satisfy <code>p</code> and it has at least one child, then it should be replaced with it's leftmost child <code>l</code> and it's remaining children should be should be appended to the <b>front</b> of the children of <code>l</code>. The resulting tree should then be recursively filtered.</li><li>If the value at a node does not satisfy <code>p</code> and it has no children, then the result should be <code>None</code>.</li></ul></div></div><h3 id="random-walks"><a href="#random-walks" class="anchor"></a>Random Walks</h3><p>We can think of a function <code>p</code> of type <code>int -&gt; int</code> as a <i>path generator</i> in the (infinite) complete graph on integers. Given a starting value <code>start</code>, the path of length 3 generated by <code>p</code> starting at <code>start</code> is</p><pre class="language-ocaml"><code>[start; p start; p (p start); p (p (p start))]</code></pre><p>For example, the function <code>fun x -&gt; x + 2</code> generates the length 5 path <code>[0;2;4;6;8;10]</code> starting at <code>0</code>.</p><p>We can analogously, think of a function <code>r</code> of the similar type <code>int -&gt; int list</code> as a <em>random walk generator</em> in the same graph. Rather than taking a single step from <code>x</code> to <code>r x</code>, we can choose of the vertices uniformly at random from <code>r x</code>.</p><p>For example, the classic <a href="https://en.wikipedia.org/wiki/Random_walk">drunkards walk</a> can be represented by the function</p><pre class="language-ocaml"><code>let drunkard x = [x + 1; x - 1]</code></pre><p>As we've learned from several of the prerequistes for this course, taking a random walk for a number of steps <code>n</code> from a starting point <code>start</code> defines a distribution over the vertices in our graph, telling us the probability of being at a each vertex after taking <code>n</code> steps from <code>start</code>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-rat"><a href="#type-rat" class="anchor"></a><code><span><span class="keyword">type</span> rat</span><span> = </span><span>{</span></code><ol><li id="type-rat.num" class="def record field anchored"><a href="#type-rat.num" class="anchor"></a><code><span>num : int;</span></code></li><li id="type-rat.denom" class="def record field anchored"><a href="#type-rat.denom" class="anchor"></a><code><span>denom : int;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-distr"><a href="#type-distr" class="anchor"></a><code><span><span class="keyword">type</span> distr</span><span> = <span><span>(int * <a href="#type-rat">rat</a>)</span> list</span></span></code></div><div class="spec-doc"><p>We can define a (discrete) probability distribution to be a collection of values paired with rational numbers, representing the probability of each value. If a value does not appear in this list, then it has probability <code>0</code>. We maintain that:</p><ul><li>the sum of the probabilites is <code>1</code>;</li><li>there is at most one pair <code>(v, prob)</code> for any value <code>v</code>;</li><li>the values are in increasing order;</li><li>the rational numbers in the distribution are in reduced form.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-random_walk"><a href="#val-random_walk" class="anchor"></a><code><span><span class="keyword">val</span> random_walk : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>int list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-distr">distr</a></span></code></div><div class="spec-doc"><p>Implement the function <code>random_walk</code> so that the distribution <code>random_walk walk start num_steps</code> is the one defined over vertices of the complete graph on integers after taking an <code>num_steps</code> length random walk starting at <code>start</code>. Specifically, if the probability of being at vertex <code class="odoc-katex-math">n</code> is <code class="odoc-katex-math">p</code>, then <code class="odoc-katex-math">(n, p)</code> should appear in the resulting distribution.</p><pre class="language-ocaml"><code>assert (random_walk drunkard 0 0 = [(0, {num=1;rat=1})])
assert (random_walk drunkard 0 1 = [(-1, {num=1;rat=2}); (1, {num=1;rat=2})])
assert (random_walk drunkard 0 2
        = [(-2, {num=1;rat=4}); (0, {num=1;rat=2}), (2, {num=1;rat=4})])</code></pre><p><b>Important:</b> You may assume that <code>walk n</code> is nonempty for every integer <code>n</code>.</p></div></div><h2 id="written"><a href="#written" class="anchor"></a>Written</h2><h3 id="an-ocaml-puzzle"><a href="#an-ocaml-puzzle" class="anchor"></a>An OCaml Puzzle</h3><pre class="language-ocaml"><code>type 'a foo = Foo of ('a foo -&gt; 'a)
let bar (Foo f) = f
let baz x = bar x x
let out = baz ???</code></pre><p>Consider the above OCaml program. Given an expression to put in place of <code>???</code> so that <code>out</code> evaluates to the integer <code>42</code>. Explain your answer.</p><h3 id="typing-derivation"><a href="#typing-derivation" class="anchor"></a>Typing Derivation</h3><div><pre class="odoc-katex-math display">   \varnothing \vdash
   \texttt{let a = let b = 3 in b + b in (a, true)} : \tau
   </pre></div><p>Determine a type <code class="odoc-katex-math">\tau</code> such that the above typing judgment is derivable, and give the derivation.</p><h3 id="semantic-derivation"><a href="#semantic-derivation" class="anchor"></a>Semantic Derivation</h3><div><pre class="odoc-katex-math display">   \texttt{let a = let b = 3 in b + b in 4 * a} \Downarrow v
   </pre></div><p>Determine a value <code class="odoc-katex-math">v</code> such that the above semantic judgment is derivable, and give the derviation.</p></div></body></html>
