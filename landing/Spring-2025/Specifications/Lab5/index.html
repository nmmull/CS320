<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lab5 (Spring-2025.Specifications.Lab5)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Lab5</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Lab5</span></code></h1><p>Higher-order functions are particularly useful when we have to do a lot of list processing, e.g., for many applications in scheduling. In this lab, we'll be building a toy-version of <a href="https://www.when2meet.com">when2meet</a>, an online tool for determining a meeting time against a collection of potentially conflicting schedules.</p><p>Pull down the course repository to get the starter code for this lab in the directory <code>labs/lab5</code>.</p></header><nav class="odoc-toc"><ul><li><a href="#intervals-and-schedules">Intervals and Schedules</a></li><li><a href="#prelude:-comparison">Prelude: Comparison</a></li><li><a href="#intersecting-schedules">Intersecting Schedules</a></li><li><a href="#parsing-intervals">Parsing Intervals</a></li><li><a href="#putting-everything-together">Putting Everything Together</a></li></ul></nav><div class="odoc-content"><h2 id="intervals-and-schedules"><a href="#intervals-and-schedules" class="anchor"></a>Intervals and Schedules</h2><p>Suppose that we're trying to schedule a meeting for a group of people. Each person has windows of time at which they are available to meet. Our job is to collect those times and determine during which windows everyone in the group is available.</p><p>We'll call a window of time an <i>interval</i>. An interval consists of a <i>day</i> of the week and a <i>starting time</i> and <i>ending time</i>. Times will be written in 24-hour notation, and we'll only allow the minute-part of a time to be <code>:00</code>, <code>:15</code>, <code>:30</code>, or <code>:45</code> (this is consistent with when2meet). We will also assume that an interval does not span multiple days.</p><p>A <i>schedule</i> is then defined to be a list of intervals. As a simplifying assumption, we'll assume that <i>all intervals in a schedule are disjoint</i> (you can try to remove this assumption by preprocessing schedules to eliminate overlaps).</p><p>All the types we've just described are given below.</p><div class="odoc-spec"><div class="spec type anchored" id="type-day"><a href="#type-day" class="anchor"></a><code><span><span class="keyword">type</span> day</span><span> = </span></code><ol><li id="type-day.Mo" class="def variant constructor anchored"><a href="#type-day.Mo" class="anchor"></a><code><span>| </span><span><span class="constructor">Mo</span></span></code></li><li id="type-day.Tu" class="def variant constructor anchored"><a href="#type-day.Tu" class="anchor"></a><code><span>| </span><span><span class="constructor">Tu</span></span></code></li><li id="type-day.We" class="def variant constructor anchored"><a href="#type-day.We" class="anchor"></a><code><span>| </span><span><span class="constructor">We</span></span></code></li><li id="type-day.Th" class="def variant constructor anchored"><a href="#type-day.Th" class="anchor"></a><code><span>| </span><span><span class="constructor">Th</span></span></code></li><li id="type-day.Fr" class="def variant constructor anchored"><a href="#type-day.Fr" class="anchor"></a><code><span>| </span><span><span class="constructor">Fr</span></span></code></li><li id="type-day.Sa" class="def variant constructor anchored"><a href="#type-day.Sa" class="anchor"></a><code><span>| </span><span><span class="constructor">Sa</span></span></code></li><li id="type-day.Su" class="def variant constructor anchored"><a href="#type-day.Su" class="anchor"></a><code><span>| </span><span><span class="constructor">Su</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-hour"><a href="#type-hour" class="anchor"></a><code><span><span class="keyword">type</span> hour</span><span> = int</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-minute"><a href="#type-minute" class="anchor"></a><code><span><span class="keyword">type</span> minute</span><span> = </span></code><ol><li id="type-minute.M00" class="def variant constructor anchored"><a href="#type-minute.M00" class="anchor"></a><code><span>| </span><span><span class="constructor">M00</span></span></code></li><li id="type-minute.M15" class="def variant constructor anchored"><a href="#type-minute.M15" class="anchor"></a><code><span>| </span><span><span class="constructor">M15</span></span></code></li><li id="type-minute.M30" class="def variant constructor anchored"><a href="#type-minute.M30" class="anchor"></a><code><span>| </span><span><span class="constructor">M30</span></span></code></li><li id="type-minute.M45" class="def variant constructor anchored"><a href="#type-minute.M45" class="anchor"></a><code><span>| </span><span><span class="constructor">M45</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-time"><a href="#type-time" class="anchor"></a><code><span><span class="keyword">type</span> time</span><span> = </span><span>{</span></code><ol><li id="type-time.hour" class="def record field anchored"><a href="#type-time.hour" class="anchor"></a><code><span>hour : <a href="#type-hour">hour</a>;</span></code></li><li id="type-time.minute" class="def record field anchored"><a href="#type-time.minute" class="anchor"></a><code><span>minute : <a href="#type-minute">minute</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-interval"><a href="#type-interval" class="anchor"></a><code><span><span class="keyword">type</span> interval</span><span> = </span><span>{</span></code><ol><li id="type-interval.day" class="def record field anchored"><a href="#type-interval.day" class="anchor"></a><code><span>day : <a href="#type-day">day</a>;</span></code></li><li id="type-interval.start_time" class="def record field anchored"><a href="#type-interval.start_time" class="anchor"></a><code><span>start_time : <a href="#type-time">time</a>;</span></code></li><li id="type-interval.end_time" class="def record field anchored"><a href="#type-interval.end_time" class="anchor"></a><code><span>end_time : <a href="#type-time">time</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-schedule"><a href="#type-schedule" class="anchor"></a><code><span><span class="keyword">type</span> schedule</span><span> = <span><a href="#type-interval">interval</a> list</span></span></code></div></div><h2 id="prelude:-comparison"><a href="#prelude:-comparison" class="anchor"></a>Prelude: Comparison</h2><p>Before getting into the bulk of this lab, we need to take some time to look at <em>comparison</em> functions.</p><p>It would be nice if we could order the schedule output by our program by day and starting time. If you take a look at <code>bin/main.ml</code>, you'll see that this is one step in the process. But the <code>sort</code> function in the OCaml standard library doesn't take an boolean ordering function, it takes a more general <em>comparison</em> function.</p><p>A comparison function <code>compare</code> on <code>'a</code> is a function of type <code>'a -&gt; 'a -&gt; int</code> such that <code>compare x y</code> is:</p><ul><li>positive if <code>x &gt; y</code></li><li><code>0</code> if <code>x = y</code></li><li>negative if <code>x &lt; y</code></li></ul><p>The benefit of such a function is that we don't need to remember which boolean ordering function we need to pass into <code>sort</code> (e.g., is it <code>(&lt;)</code> or <code>(&lt;=)</code> or maybe even <code>(&gt;)</code>). Other functions can be parametrized by comparison functions, e.g., the <code>min</code> and <code>max</code> functions provided in the starter code.</p><p>We'll start by getting some practice with this.</p><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="#type-interval">interval</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Implement the function <code>is_empty</code> so that <code>is_empty i</code> is <code>true</code> if <code>i</code> the starting time of <code>i</code> is greater than or equal to the end time of <code>i</code> and <code>false</code> otherwise. <i>Hint:</i> Use <code>compare_time</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_interval"><a href="#val-compare_interval" class="anchor"></a><code><span><span class="keyword">val</span> compare_interval : <span><a href="#type-interval">interval</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-interval">interval</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Implement the function <code>compare_interval</code> so that it is a comparison function for intervals as described above <em>which orders intervals by day and start_time.</em> For example, any interval on Wednesday should appear before any interval on Friday, but given two intervals on Wednesday, the one with earlier starting time should appear first, or they should be considered equal if they have the same starting time.</p></div></div><p>Make sure to look at the code given to you. In particular, see how comparison functions are defined for other types like <code>day</code> and <code>minute</code> and <code>time</code>. Also note that Monday is the <em>first</em> day in our ordering of days.</p><h2 id="intersecting-schedules"><a href="#intersecting-schedules" class="anchor"></a>Intersecting Schedules</h2><p>The primary objective of this lab is determine the intersection of multiple schedules. It will be easiest to solve a sequence of sub-problems:</p><ul><li>intersect an interval with an interval</li><li>intersect an interval with a schedule</li><li>intersect two schedules</li><li>intersect a list of schedules</li></ul><p>Many of these problems have natural implementations using higher-order functions, and we recommend trying to implement them in this way.</p><div class="odoc-spec"><div class="spec value anchored" id="val-intersect_i_i"><a href="#val-intersect_i_i" class="anchor"></a><code><span><span class="keyword">val</span> intersect_i_i : <span><a href="#type-interval">interval</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-interval">interval</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-interval">interval</a> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>intersect_i_i</code> so that <code>intersect_i_i i1 i2</code> is <code>None</code> if <code>i1</code> and <code>i2</code> have empty intersection, and otherwise is <code>Some i</code> where <code>i</code> is the intersection of <code>i1</code> and <code>i2</code>. <i>Note:</i> Two intervals can have nonempty intersection only if they are on the same day.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intersect_s_i"><a href="#val-intersect_s_i" class="anchor"></a><code><span><span class="keyword">val</span> intersect_s_i : <span><a href="#type-schedule">schedule</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-interval">interval</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-schedule">schedule</a></span></code></div><div class="spec-doc"><p>Implement the function <code>intersect_s_i</code> so that <code>intersect_s_i s i</code> is the schedule of intervals in <code>s</code> intersected with <code>i</code>. <i>Hint:</i> Use <code>List.filter</code> and <code>List.map</code> (or <code>List.filter_map</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intersect_s_s"><a href="#val-intersect_s_s" class="anchor"></a><code><span><span class="keyword">val</span> intersect_s_s : <span><a href="#type-schedule">schedule</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-schedule">schedule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-schedule">schedule</a></span></code></div><div class="spec-doc"><p>Implement the function <code>intersect_s_s</code> so that <code>intersect_s_s s1 s2</code> is a schedule of intervals consisting of the intersections of <code>s1</code> and <code>s2</code> (it may help to draw a picture). <i>Hint:</i> Use <code>List.fold_left</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intersect_schedules"><a href="#val-intersect_schedules" class="anchor"></a><code><span><span class="keyword">val</span> intersect_schedules : <span><span><a href="#type-schedule">schedule</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-schedule">schedule</a></span></code></div><div class="spec-doc"><p>Implement the function <code>intersect_schedules</code> so that <code>intersect_schedules scheds</code> is the intersection of all schedules in <code>scheds</code>. Given the empty list, it should produce a schedule containing all available time. <i>Hint.</i> Use <code>List.fold_left</code>.</p></div></div><p>Again, this is the core functionality of our program. What follows will allow us to read in and print out schedules so that we can interact with this core functionality.</p><h2 id="parsing-intervals"><a href="#parsing-intervals" class="anchor"></a>Parsing Intervals</h2><p>Our program will work by reading schedules from files given at the command line. We can imagine having every person in the group sending us a file consisting of intervals during which they're available, and we can then run our program on all the files we receive.</p><p>For exapmle, if <code>Kiki</code> and <code>Tombo</code> send us their schedules in the files <code>kiki.sch</code> and <code>tombo.sch</code>, respectively, then we'll be able to run:</p><pre class="language-text"><code>dune exec lab5 -- kiki.sch tombo.sch</code></pre><p>in order to determine when they are both available to meet.</p><p>A schedule file will consist of several lines, each of which contains an interval. There will be one interval per line. For example:</p><pre class="language-text"><code>Mo  08:00--12:00
Th  10:00--13:00
Mo  14:00--18:00
Fr  15:00--17:00</code></pre><p>The time-part of an interval will be written as two times separated by <code>--</code>, with no whitespace. We will require that a time is written with 5 characters, so 8:00AM must be written as <code>08:00</code>. The day-part will be written first, and should consist of the two first letters of the day with the first letter capitalized. Besides these restrictions, a schedule file is whitespace agnostic, e.g., this would also be a valid schedule:</p><pre class="language-text"><code>             Mo           08:00--12:00
  Th        10:00--13:00
Mo  14:00--18:00
    Fr       15:00--17:00</code></pre><p>Note that it is possible to have multiple intervals for a single day, and intervals are not required to be in order.</p><p>For this lab, we've handled reading the lines of each file for you (if you're interested, take a look at <code>bin/main.ml</code>). Your task is to parse a single line into an <code>interval</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-interval_of_string_opt"><a href="#val-interval_of_string_opt" class="anchor"></a><code><span><span class="keyword">val</span> interval_of_string_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-interval">interval</a> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>interval_of_string_opt</code> so that <code>interval_of_string_opt s</code> is <code>Some i</code> where <code>i</code> is the <code>interval</code> represented by <code>s</code> according to the above rules, and is <code>None</code> otherwise. You should assume that <code>s</code> is trimmed, i.e., there is no whitespace at the start or end of the <code>s</code>.</p></div></div><p>Again, make sure to look at the functions already defined for you in <code>lib/lab5.ml</code>. A number of them will be helpful in solving this problem.</p><h2 id="putting-everything-together"><a href="#putting-everything-together" class="anchor"></a>Putting Everything Together</h2><p>Once we've implemented everything above, we should be able to pass in multiple file names to our program as command line arguments and check when everyone is available to meet:</p><pre class="language-text"><code>dune exec lab5 -- sched1.sch sched2.sch sched3.sch</code></pre><p>We've included a couple small example schedules, but you can try it out yourself on larger schedules.</p></div></body></html>
