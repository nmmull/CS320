<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stdlib320 (Spring-2025.Specifications.Stdlib320)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Stdlib320</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Stdlib320</span></code></h1><p>The following is the standard library we'll use for the first half of <i>CAS CS 320: Concepts of Programming Languages</i> at Boston University (Spring 2025). It's a <i>very</i> small subset of the OCaml Standard Library with a bit more documentation (it also gives us more control over what functions are &quot;allowed&quot; for assignments). Nearly everything here is also available in the OCaml Standard Library, so check the <a href="https://ocaml.org/manual/5.2/api/Stdlib.html"><code>Stdlib</code> documentation</a> for more information on what you see below.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#integer-arithmetic">Integer arithmetic</a><ul><li><a href="#precedence-and-associativity">Precedence and Associativity</a></li></ul></li><li><a href="#floating-point-arithmetic">Floating-point arithmetic</a></li><li><a href="#boolean-operations">Boolean operations</a></li><li><a href="#comparisons">Comparisons</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#input/output">Input/Output</a><ul><li><a href="#printing">Printing</a></li><li><a href="#reading">Reading</a></li></ul></li><li><a href="#basic-ocaml-types">Basic OCaml Types</a><ul><li><a href="#functions">Functions</a></li><li><a href="#integers">Integers</a></li><li><a href="#floats">Floats</a></li><li><a href="#booleans">Booleans</a></li><li><a href="#characters">Characters</a></li><li><a href="#strings">Strings</a></li><li><a href="#lists">Lists</a></li><li><a href="#options">Options</a></li><li><a href="#results">Results</a></li><li><a href="#nonempty-trees">Nonempty Trees</a></li></ul></li><li><a href="#exception-handling">Exception Handling</a></li><li><a href="#extra-utilities">Extra Utilities</a><ul><li><a href="#trigonometric-functions">Trigonometric Functions</a></li><li><a href="#randomness">Randomness</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="integer-arithmetic"><a href="#integer-arithmetic" class="anchor"></a>Integer arithmetic</h2><p>Like most programming languages, OCaml has infix arithmetic operators. That said, the following operators can only be applied to integers. Arithmetic operations for floating-point numbers are defined in the next section. <b>There are no arithmetic operators for any other type (strings, lists, etc.)</b></p><p>In OCaml, infix operators can be used as (Curry-ed) prefix operators by surrounding them in parentheses, e.g., <code>(+) 11 13</code> has the same value as <code>11 + 13</code>. Any function below whose name is surrounded in parentheses can be used as an infix binary operator.</p><div class="odoc-spec"><div class="spec value anchored" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span><span class="keyword">val</span> (+) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Integer addition</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(-)"><a href="#val-(-)" class="anchor"></a><code><span><span class="keyword">val</span> (-) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Integer subtraction</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(*)"><a href="#val-(*)" class="anchor"></a><code><span><span class="keyword">val</span> (*) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Integer multiplication</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span><span class="keyword">val</span> (/) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Integer division in OCaml is implemented as Euclidean division, which rounds towards <code>0</code> (this differs from integer division in Python, which is implemented as floored division).</p><pre class="language-ocaml"><code>let _ = assert (5 / 3 = 1)
let _ = assert ((-5) / 3 = -1)
let _ = assert (5 / (-3) = -1)</code></pre><p>Raises a <code>Division_by_zero</code> exception if the second argument evaluates to <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(mod)"><a href="#val-(mod)" class="anchor"></a><code><span><span class="keyword">val</span> (mod) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Integer remainder is implemented so as to satisfy the following properties:</p><ul><li><code>x mod y = x mod (abs y)</code></li><li><code>(- x) mod y = - (x mod y)</code></li></ul><p>For positive integers it's the remainder of <code>x / y</code> in the grade school sense:</p><ul><li><code>x / y * y + x mod y = x</code></li></ul><p>Raises a <code>Division_by_zero</code> exception if the second argument evaluates to <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-abs"><a href="#val-abs" class="anchor"></a><code><span><span class="keyword">val</span> abs : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Integer absolute value</p></div></div><h3 id="precedence-and-associativity"><a href="#precedence-and-associativity" class="anchor"></a>Precedence and Associativity</h3><p>Once we have binary operators, we have to discuss precedence and associativity. This will be a formal topic when we cover parsing. For now, we'll piggy-back on your intuitions about mathematical expressions from grade school.</p><p>We can surround an expression with parentheses in order to use it as an operand of an infix binary operator, e.g., the expression <code>(1 + 2) * 3</code> has the subexpression <code>1 + 2</code> as its left operand. If we leave out the parentheses, the expression is ambiguous; it's unclear <i>a priori</i> if <code>1 + 2 * 3</code> should have the same value as <code>(1 + 2) * 3</code> or <code>1 + (2 * 3)</code>. We assign operators <i>precedence</i> and <i>associativity</i> in order to resolve ambiguities.</p><p>One way to eliminate the ambiguity in the example above it to rank operators by <i>precedence</i>. Operators are evaluated in order of decreasing precedence, i.e., operators with higher precedence are evaluated first. It's also said that operators of higher precedence &quot;bind tighter&quot; than operators of lower precedence. More familiarly, you may have learned the acronym PEMDAS, which defines the order of operations (i.e., relative precedence of operators) for arithemtic expressions. For the above example, the expression <code>1 + 2 * 3</code> should have the same value as the expression <code>1 + (2 * 3)</code>.</p><p>Given precedence, it's still possible for there to be ambiguity with operators of the same precedence, e.g., it's unclear <i>a priori</i> if <code>1 - 2 - 3</code> should have the same value as <code>(1 - 2) - 3</code> or <code>1 - (2 - 3)</code>. We eliminate this ambiguity by assigning operators <i>associativity</i>, either left, right, or no associativity. For left associative operators, parentheses group to the left, i.e., operators furthest left are evaluated first. So <code>1 - 2 - 3</code> has the same value as <code>(1 - 2) - 3</code>. The analogous is true for the right associativity operators.</p><p>We're eliding some details, but hopefully this should make sufficiently clear how to read expressions with binary operators in OCaml. For full details on precedence and associativity of built-in operators in OCaml, see the <a href="https://ocaml.org/manual/5.3/api/Ocaml_operators.html">OCaml manual page on operators</a>.</p><h2 id="floating-point-arithmetic"><a href="#floating-point-arithmetic" class="anchor"></a>Floating-point arithmetic</h2><p>From the OCaml Standard Library: &quot;OCaml's floating-point numbers follow the IEEE 754 standard, using double precision (64 bits) numbers. Floating-point operations never raise an exception on overflow, underflow, division by zero, etc. Instead, special IEEE numbers are returned as appropriate...&quot; See <a href="https://ocaml.org/manual/5.2/api/Stdlib.html#1_Floatingpointarithmetic">this paragraph</a> for more details.</p><p>Note that the first four arithmetic operators have a '<code>.</code>' following them. This distinguishes them from the corresponding arithmetic operators for integers. <b>OCaml does not support operator overloading.</b></p><div class="odoc-spec"><div class="spec value anchored" id="val-(+.)"><a href="#val-(+.)" class="anchor"></a><code><span><span class="keyword">val</span> (+.) : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Floating-point addition</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(-.)"><a href="#val-(-.)" class="anchor"></a><code><span><span class="keyword">val</span> (-.) : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Floating-point subtraction</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(*.)"><a href="#val-(*.)" class="anchor"></a><code><span><span class="keyword">val</span> (*.) : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Floating-point multiplication</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/.)"><a href="#val-(/.)" class="anchor"></a><code><span><span class="keyword">val</span> (/.) : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Floating-point division</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(**)"><a href="#val-(**)" class="anchor"></a><code><span><span class="keyword">val</span> (**) : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Exponentiation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><code><span><span class="keyword">val</span> sqrt : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Square root</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp"><a href="#val-exp" class="anchor"></a><code><span><span class="keyword">val</span> exp : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Exponential</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log"><a href="#val-log" class="anchor"></a><code><span><span class="keyword">val</span> log : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Natural logarithm</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceil"><a href="#val-ceil" class="anchor"></a><code><span><span class="keyword">val</span> ceil : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Round up to the nearest integer (returned as a <code>float</code>)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floor"><a href="#val-floor" class="anchor"></a><code><span><span class="keyword">val</span> floor : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Round down to the nearest an integer</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-abs_float"><a href="#val-abs_float" class="anchor"></a><code><span><span class="keyword">val</span> abs_float : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Floating-point absolute value</p></div></div><h2 id="boolean-operations"><a href="#boolean-operations" class="anchor"></a>Boolean operations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-not"><a href="#val-not" class="anchor"></a><code><span><span class="keyword">val</span> not : <span>bool <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Boolean negation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&amp;&amp;)"><a href="#val-(&amp;&amp;)" class="anchor"></a><code><span><span class="keyword">val</span> (&amp;&amp;) : <span>bool <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Boolean conjunction (and)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(||)"><a href="#val-(||)" class="anchor"></a><code><span><span class="keyword">val</span> (||) : <span>bool <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Boolean disjunction (or)</p></div></div><h2 id="comparisons"><a href="#comparisons" class="anchor"></a>Comparisons</h2><p>The comparison operators in OCaml are <i>polymorphic</i>. This means any two expressions of the same type may be compared, with the exception of functions; comparison operators raise an <code>Invalid_argument</code> exception if two functions are compared. Comparison operators behave as expected on Boolean values, strings, lists, options, etc.</p><div class="odoc-spec"><div class="spec value anchored" id="val-(=)"><a href="#val-(=)" class="anchor"></a><code><span><span class="keyword">val</span> (=) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Structural equality. This is <code>==</code> in most other languages. As an aside, you should generally avoid using this for floating-point numbers, and should instead compare floating point numbers up to a given tolerance.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;&gt;)"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;&gt;) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Structural inequality, i.e., <code>x &lt;&gt; y</code> is equivalent to <code>not (x = y)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;)"><a href="#val-(&lt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Structural less-than</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;)"><a href="#val-(&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Structural greater-than</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;=)"><a href="#val-(&lt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;=) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Structural less-than-or-equal-to, i.e., <code>x &lt;= y</code> is equivalent to <code>not (x &gt; y)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;=)"><a href="#val-(&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;=) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Structural greater-than-or-equal-to</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-min"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Minimum of its two arguments</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-max"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Maximum of its two arguments</p></div></div><h2 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h2><p>Unlike many other programming languages, <b>OCaml does not support implicit type conversion</b>; all conversions must be done explicitly. The OCaml standard library includes a small collection of useful conversions.</p><div class="odoc-spec"><div class="spec value anchored" id="val-float_of_int"><a href="#val-float_of_int" class="anchor"></a><code><span><span class="keyword">val</span> float_of_int : <span>int <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Converts an integer into a floating-point number</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int_of_float"><a href="#val-int_of_float" class="anchor"></a><code><span><span class="keyword">val</span> int_of_float : <span>float <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Converts a floating-point number into an integer by rounding towards <code>0</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int_of_char"><a href="#val-int_of_char" class="anchor"></a><code><span><span class="keyword">val</span> int_of_char : <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Converts a character into its ASCII code</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-char_of_int"><a href="#val-char_of_int" class="anchor"></a><code><span><span class="keyword">val</span> char_of_int : <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p>Converts an ASCII code into a character, raising an <code>Invalid_argument</code> exception if its argument is not a valid ASCII code</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_bool"><a href="#val-string_of_bool" class="anchor"></a><code><span><span class="keyword">val</span> string_of_bool : <span>bool <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Converts a Boolean value to a string</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bool_of_string"><a href="#val-bool_of_string" class="anchor"></a><code><span><span class="keyword">val</span> bool_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Converts a string to a Boolean value, raising a <code>Failure</code> exception if the argument doesn't evaluate to <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bool_of_string_opt"><a href="#val-bool_of_string_opt" class="anchor"></a><code><span><span class="keyword">val</span> bool_of_string_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span>bool option</span></span></code></div><div class="spec-doc"><p>Same as the previous function, but is <code>None</code> in the case of failure</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_int"><a href="#val-string_of_int" class="anchor"></a><code><span><span class="keyword">val</span> string_of_int : <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Converts an integer to a string</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int_of_string"><a href="#val-int_of_string" class="anchor"></a><code><span><span class="keyword">val</span> int_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Converts a string to an integer, raising a <code>Failure</code> exception if the argument doesn't represent a integer</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int_of_string_opt"><a href="#val-int_of_string_opt" class="anchor"></a><code><span><span class="keyword">val</span> int_of_string_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p>Same as the previous function, but is <code>None</code> in the case of failure</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_float"><a href="#val-string_of_float" class="anchor"></a><code><span><span class="keyword">val</span> string_of_float : <span>float <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Converts an floating-pofloat number to a string</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float_of_string"><a href="#val-float_of_string" class="anchor"></a><code><span><span class="keyword">val</span> float_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Converts a string to an floating-pofloat number, raising a <code>Failure</code> exception if the argument doesn't represent a floating-pofloat number</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float_of_string_opt"><a href="#val-float_of_string_opt" class="anchor"></a><code><span><span class="keyword">val</span> float_of_string_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span>float option</span></span></code></div><div class="spec-doc"><p>Same as the previous function, but is <code>None</code> in the case of failure</p></div></div><h2 id="input/output"><a href="#input/output" class="anchor"></a>Input/Output</h2><h3 id="printing"><a href="#printing" class="anchor"></a>Printing</h3><p>One complaint we frequently receive about OCaml is that it's difficult to do intermediate printing. If you want to print something in the definition of a function, you just have to create a dummy variable and use a printing function.</p><pre class="language-ocaml"><code>let add_one (x : int) : int =
  let _ = print (string_of_int x) in
  x + 1</code></pre><p>There are better ways of doing this but I recommend this approach to beginners.</p><p>There is no generic printing function (we don't want one). That said, we've included additional printing functions in the individual modules for each types, e.g.,</p><pre class="language-ocaml"><code>let add_one (x : int) : int =
  let _ = Int.print x in
  x + 1</code></pre><p>We've included the following printing functions because they're included in the standard library.</p><div class="odoc-spec"><div class="spec value anchored" id="val-print_int"><a href="#val-print_int" class="anchor"></a><code><span><span class="keyword">val</span> print_int : <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Prints an integer to standard output</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_float"><a href="#val-print_float" class="anchor"></a><code><span><span class="keyword">val</span> print_float : <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Prints a floating-point number to standard output</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_string"><a href="#val-print_string" class="anchor"></a><code><span><span class="keyword">val</span> print_string : <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>prints a string to standard output</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_endline"><a href="#val-print_endline" class="anchor"></a><code><span><span class="keyword">val</span> print_endline : <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Prints a string followed by a newline character to standard output</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>print</code> is an alias for <code>print_endline</code></p></div></div><h3 id="reading"><a href="#reading" class="anchor"></a>Reading</h3><p>We'll primarily be using reading functions to read in files when we build interpreters.</p><div class="odoc-spec"><div class="spec value anchored" id="val-read_line"><a href="#val-read_line" class="anchor"></a><code><span><span class="keyword">val</span> read_line : <span>unit <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Reads a line (upto a newline character) from standard input, where the output does not include a the newline character</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span>unit <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Reads everything from standard input</p></div></div><h2 id="basic-ocaml-types"><a href="#basic-ocaml-types" class="anchor"></a>Basic OCaml Types</h2><h3 id="functions"><a href="#functions" class="anchor"></a>Functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-(|&gt;)"><a href="#val-(|&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (|&gt;) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>x |&gt; f |&gt; g</code> is equivalent to <code>g (f x)</code>. This operator is useful for <a href="https://cs3110.github.io/textbook/chapters/basics/functions.html#pipeline">pipelining</a></p></div></div><h3 id="integers"><a href="#integers" class="anchor"></a>Integers</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Int"><a href="#module-Int" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Int/index.html">Int</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing printers for integers</p></div></div><h3 id="floats"><a href="#floats" class="anchor"></a>Floats</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Float"><a href="#module-Float" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Float/index.html">Float</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing printers for floats, and the value <code>pi</code></p></div></div><h3 id="booleans"><a href="#booleans" class="anchor"></a>Booleans</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Bool"><a href="#module-Bool" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Bool/index.html">Bool</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing printers for Boolean values</p></div></div><h3 id="characters"><a href="#characters" class="anchor"></a>Characters</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Char"><a href="#module-Char" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Char/index.html">Char</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing printers for characters</p></div></div><h3 id="strings"><a href="#strings" class="anchor"></a>Strings</h3><p>Strings in OCaml are sequences of bytes. It's important to note that string are <i>not</i> lists of characters, and it is generally good practice not to think of them as such. We don't do much string manipulation in this course (but we will do some). See the <a href="https://ocaml.org/manual/5.3/api/String.html">OCaml docs on Strings</a> for more details.</p><div class="odoc-spec"><div class="spec value anchored" id="val-(^)"><a href="#val-(^)" class="anchor"></a><code><span><span class="keyword">val</span> (^) : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>String concatenation</p><pre class="language-ocaml"><code>let _ = assert (&quot;hello&quot; ^ &quot;world&quot; ^ &quot;!&quot; = &quot;hello world!&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-String"><a href="#module-String" class="anchor"></a><code><span><span class="keyword">module</span> <a href="String/index.html">String</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing basic string operations</p></div></div><h3 id="lists"><a href="#lists" class="anchor"></a>Lists</h3><p>Lists are ordered sequences of elements of the same type. They are <i>not</i> the same as arrays. They are defined by the following ADT.</p><pre class="language-ocaml"><code>type 'a t = 'a list =
| []
| (::) of 'a * 'a list

let empty_list = []
let example_cons = 1 :: 2 :: 3 :: []
let example_lit = [1;2;3]
let _ = assert (example_cons = example_lit)</code></pre><div class="odoc-spec"><div class="spec value anchored" id="val-(@)"><a href="#val-(@)" class="anchor"></a><code><span><span class="keyword">val</span> (@) : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>List concatenation</p><pre class="language-ocaml"><code>let _ = assert ([[1;2;3] @ [4;5;6] @ [7;8;9] = [1;2;3;4;5;6;7;8;9]])</code></pre></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-List"><a href="#module-List" class="anchor"></a><code><span><span class="keyword">module</span> <a href="List/index.html">List</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing basic list operations</p></div></div><h3 id="options"><a href="#options" class="anchor"></a>Options</h3><p>An option is like a box that might contain a value. It is given by the following ADT:</p><pre class="language-ocaml"><code>type 'a option = None | Some of 'a</code></pre><p>They are used for defining partial functions, i.e., functions which are not defined on all inputs. For example, we can write the following function which returns the first element of a list, given the list is nonempty.</p><pre class="language-ocaml"><code>let first (l : 'a list) : 'a option =
  match l with
  | [] -&gt; None
  | x :: _ -&gt; Some x</code></pre><p>If <code>l</code> is empty, <code>first l</code> is <code>None</code>. This is <i>not</i> the same thing as a null pointer. <code>None</code> is a constructor for a datatype. Same with <code>Some</code>; in particular, <code>Some 2</code> is not the same as <code>2</code> (they're not even the same type).</p><div class="odoc-spec"><div class="spec module anchored" id="module-Option"><a href="#module-Option" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Option/index.html">Option</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing basic operations for options.</p></div></div><h3 id="results"><a href="#results" class="anchor"></a>Results</h3><p>A result is the same as an option except that the &quot;none&quot; case carried data. It's given by the following ADT. As with options, they are used to define partial functions, but particularly in the case that we want more information in the error case.</p><div class="odoc-spec"><div class="spec type anchored" id="type-result"><a href="#type-result" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) result</span></span><span> = </span></code><ol><li id="type-result.Ok" class="def variant constructor anchored"><a href="#type-result.Ok" class="anchor"></a><code><span>| </span><span><span class="constructor">Ok</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></li><li id="type-result.Error" class="def variant constructor anchored"><a href="#type-result.Error" class="anchor"></a><code><span>| </span><span><span class="constructor">Error</span> <span class="keyword">of</span> <span class="type-var">'b</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Result"><a href="#module-Result" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Result/index.html">Result</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing basic result operations</p></div></div><h3 id="nonempty-trees"><a href="#nonempty-trees" class="anchor"></a>Nonempty Trees</h3><p>Nonempty trees are not a part of the OCaml standard library, but they're useful to have. In particular, we've included a printer for nonempty trees which will be useful for visualizing heirarchical data. Trees are given by the following ADT.</p><p>These are nonempty <code class="odoc-katex-math">n</code>-ary trees. Note that there is no &quot;leaf&quot; case; a leaf is a node with an empty list of children.</p><div class="odoc-spec"><div class="spec type anchored" id="type-ntree"><a href="#type-ntree" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a ntree</span></span><span> = </span></code><ol><li id="type-ntree.Node" class="def variant constructor anchored"><a href="#type-ntree.Node" class="anchor"></a><code><span>| </span><span><span class="constructor">Node</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span><span class="type-var">'a</span> <a href="#type-ntree">ntree</a></span> list</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Ntree"><a href="#module-Ntree" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ntree/index.html">Ntree</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing printers for trees</p></div></div><h2 id="exception-handling"><a href="#exception-handling" class="anchor"></a>Exception Handling</h2><p>We won't do too much error handling in this course, but we will occasionally throw exceptions in the interpreters we write. See the <a href="https://ocaml.org/docs/error-handling">OCaml docs on error handling</a> and <a href="https://cs3110.github.io/textbook/chapters/data/exceptions.html">OCP section on Exceptions</a> for more details.</p><div class="odoc-spec"><div class="spec value anchored" id="val-raise"><a href="#val-raise" class="anchor"></a><code><span><span class="keyword">val</span> raise : <span>exn <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Raise an exception</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-failwith"><a href="#val-failwith" class="anchor"></a><code><span><span class="keyword">val</span> failwith : <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Raise a <code>Failure</code> exception with a given message</p></div></div><h2 id="extra-utilities"><a href="#extra-utilities" class="anchor"></a>Extra Utilities</h2><h3 id="trigonometric-functions"><a href="#trigonometric-functions" class="anchor"></a>Trigonometric Functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-cos"><a href="#val-cos" class="anchor"></a><code><span><span class="keyword">val</span> cos : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sin"><a href="#val-sin" class="anchor"></a><code><span><span class="keyword">val</span> sin : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tan"><a href="#val-tan" class="anchor"></a><code><span><span class="keyword">val</span> tan : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-acos"><a href="#val-acos" class="anchor"></a><code><span><span class="keyword">val</span> acos : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-asin"><a href="#val-asin" class="anchor"></a><code><span><span class="keyword">val</span> asin : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-atan"><a href="#val-atan" class="anchor"></a><code><span><span class="keyword">val</span> atan : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-atan2"><a href="#val-atan2" class="anchor"></a><code><span><span class="keyword">val</span> atan2 : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hypot"><a href="#val-hypot" class="anchor"></a><code><span><span class="keyword">val</span> hypot : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosh"><a href="#val-cosh" class="anchor"></a><code><span><span class="keyword">val</span> cosh : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinh"><a href="#val-sinh" class="anchor"></a><code><span><span class="keyword">val</span> sinh : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tanh"><a href="#val-tanh" class="anchor"></a><code><span><span class="keyword">val</span> tanh : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-acosh"><a href="#val-acosh" class="anchor"></a><code><span><span class="keyword">val</span> acosh : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-asinh"><a href="#val-asinh" class="anchor"></a><code><span><span class="keyword">val</span> asinh : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-atanh"><a href="#val-atanh" class="anchor"></a><code><span><span class="keyword">val</span> atanh : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><h3 id="randomness"><a href="#randomness" class="anchor"></a>Randomness</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Random"><a href="#module-Random" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Random/index.html">Random</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module containing basic operations for randomness</p></div></div></div></body></html>
