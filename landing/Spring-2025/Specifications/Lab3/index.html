<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lab3 (Spring-2025.Specifications.Lab3)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Lab3</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Lab3</span></code></h1><p>In this lab, we'll be building a <a href="https://en.wikipedia.org/wiki/Tab-separated_values">TSV reader</a>. This will require us to work with <code>string</code>s and <code>list</code>s. It will also give us an opportunity to do some IO.</p><p>This time around we've included some starter code for you, primarily so that your <code>dune</code> files are correctly configured. If you pull down the course repo, you'll see a dune project at the directory <code>labs/lab3</code>. Unless otherwise specified, you should implement your functions in a file called <code>lab3/lib/lab3.ml</code>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#splitting-strings">Splitting Strings</a></li><li><a href="#building-tables">Building Tables</a></li><li><a href="#extracting-a-column">Extracting a Column</a></li><li><a href="#io-(putting-everything-together)">IO (Putting everything together)</a></li></ul></nav></div><div class="odoc-content"><h2 id="splitting-strings"><a href="#splitting-strings" class="anchor"></a>Splitting Strings</h2><p>We won't work directly with <code>string</code>s too often in this course, but it's valuable some experience working with <code>string</code>s in OCaml. First, it's important to note that <code>string</code>s are <i>not</i> the same as <code>list</code>s of <code>char</code>acters. As we did in Assignment 1, we work with <code>string</code>s primarily by grabbing individual <code>char</code>acters or slices of the <code>string</code> using <code>String.sub</code>. This is due to how <code>string</code>s are stored in memory. We won't dwell on this, but OCaml discourages users from working with <code>string</code>s as <code>char list</code>s because doing so will likely be inefficient; we'll follow suit in this lab.</p><p>TSV stand for <em>tab-separated value</em> and is a file format similar to CSV, except with tabs instead of commas. In a TSV file, each line consists of text separated by tabs, and the entire file represents a table for which each line represents a row. This means reading a TSV file consists of two basic steps: split the file into lines by newline <code>char</code>acters (<code>'\n'</code>) so that you have a <code>string list</code> consisting of the rows of the table, and then split each row (of type <code>string</code>) by tab <code>char</code>acters (<code>'\t'</code>) into a <code>string list</code> consisting of its individual entries. In both steps, we need a function that can split a <code>string</code> with a given <code>char</code>acter as a delimiter.</p><div class="odoc-spec"><div class="spec value anchored" id="val-split_on_char"><a href="#val-split_on_char" class="anchor"></a><code><span><span class="keyword">val</span> split_on_char : <span><span class="optlabel">?ignore_trailing</span>:bool <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>split_on_char</code> so that <code>split_on_char ~ignore_trailing:b c s</code> is a <code>string list</code> consisting of all substrings of <code>s</code> delimited by the <code>char</code>acter <code>c</code>. The role of <code>ignore_trailing</code> is to determine the behavior of splitting the empty string <code>&quot;&quot;</code>. Some examples:</p><pre class="language-ocaml"><code>let _ = assert (split_on_char 'c' &quot;acbcdccec&quot;) = [&quot;a&quot;; &quot;b&quot;; &quot;d&quot;; &quot;&quot;; &quot;e&quot;; &quot;&quot;]
let _ = assert (
  split_on_char ~ignore_trailing:true 'c' &quot;acbcdccec&quot;
  = [&quot;a&quot;; &quot;b&quot;; &quot;d&quot;; &quot;&quot;; &quot;e&quot;]
)
let _ = assert (split_on_char ' ' &quot;hello  world&quot; = [&quot;hello&quot;; &quot;&quot;; &quot;world&quot;])
let _ = assert (
  split_on_char ~ignoree_trailing:true ' ' &quot;hello  world&quot;
  = [&quot;hello&quot;; &quot;&quot;; &quot;world&quot;])
let _ = assert (split_on_char 'c' &quot;&quot; = [&quot;&quot;])
let _ = assert (split_on_char ~ignore_trailing:true 'c' &quot;&quot; = [])
let _ = assert (split_on_char 'c' &quot;c&quot; = [&quot;&quot;; &quot;&quot;])
let _ = assert (split_on_char ~ignore_trailing:true 'c' &quot;c&quot; = [&quot;&quot;])</code></pre><p>A couple things to note here. First off, we're using an <a href="https://cs3110.github.io/textbook/chapters/basics/functions.html#labeled-and-optional-arguments">optional argument</a> for the <code>ignore_trailing</code> parameter. This is an advanced feature of OCaml that you are not required to use, but its good to know it's there. Second, the reason we include the <code>ignore_trailing</code> parameter at all is because some editors automatically include a trailing newline <code>char</code>acter at the end of file on saving, and if we split a file into lines with this trailing <code>'\n'</code>, we'll end up with a empty string at the end of our list. This paramter allows us to decide whether or not we want that last empty string.</p></div></div><h2 id="building-tables"><a href="#building-tables" class="anchor"></a>Building Tables</h2><p>Once we have a way of splitting a string on a given <code>char</code>acter, it's pretty easy to write function that will convert a <code>string</code> into a table of <code>string</code>s, represented as a <code>string list list</code>. For simplicity, we won't require that rows in our table have the same length.</p><div class="odoc-spec"><div class="spec value anchored" id="val-table_of_string"><a href="#val-table_of_string" class="anchor"></a><code><span><span class="keyword">val</span> table_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> list</span></span></code></div><div class="spec-doc"><p>Use <code>split_of_char</code> to implement the function <code>table_of_string</code> so that <code>table_of_string s</code> is a <code>string list list</code> gotten by first splitting <code>s</code> on newline <code>char</code>acters (<code>'\n'</code>) ignoring the last trailing newline character (if present), and then splitting each line on tab <code>char</code>acters (<code>'\t</code>).</p></div></div><h2 id="extracting-a-column"><a href="#extracting-a-column" class="anchor"></a>Extracting a Column</h2><p>Once we have a table, we should do something with it. One useful operation is to extract a single column from a table. But in order to define this function, we need to specify a couple things.</p><ul><li>We will determine columns of our table by identifiers given in the first row of the table. If the table is empty, the the function should fail (evaluate to <code>None</code>).</li><li>If there are multiple column with the same identifier, we'll always extract the leftmost column.</li><li>If a row does not have a value in the column we're extracting (e.g., we're extracting the 5th column and the 10th row is of length 3) the we'll assume the value in this column is the empty string <code>&quot;&quot;</code></li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-get_col"><a href="#val-get_col" class="anchor"></a><code><span><span class="keyword">val</span> get_col : <span><span><span>string list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>get_col</code> so that <code>get_col table col_id</code> is</p><ul><li><code>None</code> if the table is empty or of <code>col_id</code> is not an member of the first row of <code>table</code></li><li><code>Some col</code> where <code>col</code> is a list of all entries of the table in the column given by <code>col_id</code>, given <code>col_id</code> is a member of the first row</li></ul><p>In other words, if <code>col_id</code> is the <code class="odoc-katex-math">n</code>th member of the first row of <code>table</code>, then <code>col</code> is a list of the <code class="odoc-katex-math">n</code>th members of every row except the first row.</p></div></div><h2 id="io-(putting-everything-together)"><a href="#io-(putting-everything-together)" class="anchor"></a>IO (Putting everything together)</h2><p>We've provided code for you in the file <code>bin/main.ml</code>, but you should take a look at it because you may need to set this up yourself in the future. The contents should look something like:</p><pre class="language-ocaml"><code>let usage = &quot;USAGE: dune exec lab3 col_id &lt; tsv_file&quot;

let () =
  if Array.length (Sys.argv) &lt;&gt; 2
  then print_endline usage
  else
    let col_id = Sys.argv.(1) in
    let table_str = Stdlib320.read () in
    let table = Lab3.table_of_string table_str in
    let col = Lab3.get_row table col_id in
    match col with
    | None -&gt; print_endline (col_id ^ &quot; is not a column of the input table&quot;)
    | Some col -&gt; print_endline (String.concat &quot;\n&quot; col)</code></pre><p>Everything in the file <code>bin/main.ml</code> is executed when we run</p><pre class="language-text"><code>dune exec lab3</code></pre><p>so you can think of last expression <code>let () = ...</code> as the &quot;main&quot; function in other languages. In this expression, we take a column identifer as a command line argument and a TSV file at stdin. The <code>&lt;</code> operator is a form of <em>redirection</em>, in this case, opening the specified file for reading on stdin.</p><p>If you've done everything correctly, you should be able to run</p><pre class="language-text"><code>dune exec lab3 Email &lt; example.tsv</code></pre><p>which should print a list of emails extracted from the file <code>example.tsv</code>.</p></div></body></html>
