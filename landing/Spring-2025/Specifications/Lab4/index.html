<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lab4 (Spring-2025.Specifications.Lab4)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Lab4</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Lab4</span></code></h1><p>In the previous lab, we built a tool to build structured data (a table) from unstructured data (text in TSV format). In this lab, we'll expand on this idea by building a tool to build <em>hierarchical</em> data (a tree) from text (you may be familiar with file formats like <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> for storing hierarchical data in text) We'll be working with <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a>, which have also historically been used for the syntax of programming languages, e.g., dialects of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">LISP</a>.</p><p>Make sure to pull down the course repository to get access to starter code for this lab in the directory <code>labs/lab4</code>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#s-expressions">S-Expressions</a></li><li><a href="#tokenizing/lexing">Tokenizing/Lexing</a></li><li><a href="#parsing">Parsing</a></li><li><a href="#extra">Extra</a></li></ul></nav></div><div class="odoc-content"><h2 id="s-expressions"><a href="#s-expressions" class="anchor"></a>S-Expressions</h2><p>An <b>S-expression</b> is defined to be one of two things:</p><ul><li>An <b>atom</b>, which we will take to be any nonempty sequence of non-whitespace-non-parentheses characters.</li></ul><ul><li>An expression of the form <code class="odoc-katex-math">\texttt( e_1 \ e_2 \ \dots \ e_k \texttt)</code>, where <code class="odoc-katex-math">e_1</code> through <code class="odoc-katex-math">e_k</code> are S-expressions. In this lab, we will make the simplifying assumption that <code class="odoc-katex-math">k</code> must be at least <code class="odoc-katex-math">1</code> and that <code class="odoc-katex-math">e_1</code> is an atom, so that <code class="odoc-katex-math">\texttt{()}</code> is not a valid S-expression, and neither is <code class="odoc-katex-math">\texttt{((foo) bar)}</code>.</li></ul><p>Note that this is a <em>recursive</em> definition, and the data an S-expression denotes can be represented as a <code>string ntree</code>.</p><p><i>Example.</i> the S-expression <code>(+ (+ 3 4) (+ 5 5))</code> is a valid S-expression, which denotes the tree</p><pre class="language-ocaml"><code>let example =
  Node &quot;+&quot; [
    Node &quot;+&quot; [ Node &quot;3&quot; [], Node &quot;4&quot; []];
    Node &quot;+&quot; [ Node &quot;5&quot; [], Node &quot;5&quot; []];
  ]</code></pre><p>which could be further processed into a value of a recursive ADT:</p><pre class="language-ocaml"><code>
type expr =
  | Num of int
  | Add of expr * expr

let example = Add (Add (Num 3, Num 4), Add (Num 5, Num 5))</code></pre><p><i>Another Example.</i> We've actually already come across S-expression in this course in passing: dune files are written as S-expressions. Take a look at (part of) the dune file in this directory:</p><pre class="language-ocaml"><code>(library
 (public_name lab4)
 (libraries stdlib320))</code></pre><p>This S-expression could be represented by the following nonempty tree:</p><pre class="language-ocaml"><code>Node &quot;library&quot; [
  Node &quot;public_name&quot; [Node &quot;lab4&quot; []];
  Node &quot;libraries&quot; [Node &quot;stdlib320&quot; []];
]</code></pre><p>The goal of this lab is: <i>construct nonempty trees of strings from S-expressions</i>.</p><h2 id="tokenizing/lexing"><a href="#tokenizing/lexing" class="anchor"></a>Tokenizing/Lexing</h2><p>When we're converting text to some kind of structured data, it's useful to first break up the text into its &quot;relevant&quot; parts. As we will see in the second half of the course, this process is called <em>lexing</em> or <em>tokenizing</em>, and is a preprocessing step of <em>parsing</em>.</p><p>For example, if we're looking at the string:</p><pre class="language-ocaml"><code>&quot;(defun foo (args x y) (+ (/ x y) (/ y x)))&quot;</code></pre><p>we don't care so much that the third character is <code>'e'</code>, as much as we care that the <code>'e'</code> is part of an atom <code>&quot;defun&quot;</code> which is the second &quot;unit&quot; of the given expression. Likewise, we don't care <em>how many</em> spaces or what kind of spaces there are between atoms, just that there is whitespace.</p><div class="odoc-spec"><div class="spec type anchored" id="type-token"><a href="#type-token" class="anchor"></a><code><span><span class="keyword">type</span> token</span><span> = </span></code><ol><li id="type-token.Lparen" class="def variant constructor anchored"><a href="#type-token.Lparen" class="anchor"></a><code><span>| </span><span><span class="constructor">Lparen</span></span></code></li><li id="type-token.Rparen" class="def variant constructor anchored"><a href="#type-token.Rparen" class="anchor"></a><code><span>| </span><span><span class="constructor">Rparen</span></span></code></li><li id="type-token.Atom" class="def variant constructor anchored"><a href="#type-token.Atom" class="anchor"></a><code><span>| </span><span><span class="constructor">Atom</span> <span class="keyword">of</span> string</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tokenize"><a href="#val-tokenize" class="anchor"></a><code><span><span class="keyword">val</span> tokenize : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-token">token</a> list</span></span></code></div><div class="spec-doc"><p>The function <code>tokenize</code> separates out the parentheses and groups characters that correspond to a single atom in its input string. It also drops all whitespace. For example, the above example would be tokenized as</p><pre class="language-ocaml"><code>[Lparen; Atom &quot;defun&quot;; Atom &quot;foo&quot;; Lparen; Atom &quot;args&quot;; Atom &quot;x&quot;;...]</code></pre><p>Note that, at this point, we don't care if the input is a <em>well-formed</em> S-expression, we just care about the valid &quot;pieces&quot; of the expression, e.g.,</p><pre class="language-ocaml"><code>let _ = assert (tokenize &quot;))asdf((&quot; = [Rparen; Rparen; &quot;asdf&quot;; LParen; LParen]</code></pre><p>You don't need to do anything for this part of the lab, we've provided the function <code>tokenize</code> for you. But, if you have time, take a look at it's implementation and make sure you know what's going on in it.</p></div></div><h2 id="parsing"><a href="#parsing" class="anchor"></a>Parsing</h2><p>The bulk of the today's lab work will be the following function.</p><div class="odoc-spec"><div class="spec value anchored" id="val-ntree_of_toks"><a href="#val-ntree_of_toks" class="anchor"></a><code><span><span class="keyword">val</span> ntree_of_toks : <span><span><a href="#type-token">token</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>ntree_of_toks</code> so that <code>ntree_of_toks toks</code> is <code>None</code> if <code>toks</code> is not a valid S-expression, and is <code>Some t</code> otherwise, where <code>t</code> is a nonempty tree representation of the data in the S-expression <code>toks</code>. Some examples:</p><pre class="language-ocaml"><code>let _ = assert (ntree_of_toks [Lparen; Atom &quot;+&quot;; Atom &quot;2&quot;; Atom &quot;3&quot;; Rparen]
                = Some (Node &quot;+&quot; [Node &quot;2&quot; []; Node &quot;3&quot; []]))
let _ = assert (ntree_of_toks [Lparen; Atom &quot;+&quot;; Atom &quot;2&quot;; Atom &quot;3&quot;; Rparen; Rparen]
                = None)
let _ = assert (ntree_of_token [] = None)
let _ = assert (
  ntree_of_toks
    [Lparen; Atom &quot;+&quot;; Atom &quot;2&quot;; Lparen; Atom &quot;foo&quot;; Atom &quot;3&quot;; Rparen; Rparen]
    = Some (Node &quot;+&quot; [Node &quot;2&quot; []; Node &quot;foo&quot; [Node &quot;3&quot; []]])
)</code></pre><p>Implementing this function will require you to have a strong grasp on recursion. <em>Please spend some real time working on this, knowing how to implement a function like this is crucial for this course.</em> A hint (in addition to asking the lab TF/TA for help): it's useful to first implement a function of type:</p><pre class="language-ocaml"><code>token list -&gt; (string ntree * token list) option</code></pre><p>As you recurse, you'll want to keep track of the &quot;progress&quot; you've made, so you can return both the tree <em>and</em> the part of the input list that <em>hasn't</em> been processed yet, e.g.</p><pre class="language-ocaml"><code>let _ = assert (helper [Lparen; Atom &quot;+&quot;; Atom &quot;2&quot;; Atom &quot;3&quot;; Rparen; Rparen]
                = Some (Node &quot;+&quot; [Node &quot;2&quot; []; Node &quot;3&quot; []], [Rparen]))</code></pre><p>That way, you can &quot;continue&quot; on the part that hasn't been processed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span> option</span></span></code></div><div class="spec-doc"><p>Once you've finished this <code>ntree_of_toks</code>, you should be able to parse and print S-expressions:</p><pre class="language-text"><code>utop&gt;
match Lab4.parse
&quot;
(library
 (public_name lab4)
 (libraries stdlib320))
&quot;
with
| None -&gt; ()
| Some t -&gt; Stdlib320.Ntree.print (fun x -&gt; x) t;;

library
â”œâ”€â”€public_name
â”‚  â””â”€â”€lab4
â””â”€â”€libraries
   â””â”€â”€stdlib320
- : unit = ()</code></pre></div></div><h2 id="extra"><a href="#extra" class="anchor"></a>Extra</h2><p>If you finish <code>ntree_of_toks</code>, then there are a couple extensions you could work on:</p><ul><li>Fill in <code>bin/main.ml</code> to take input at stdin as in Lab 3.</li><li>Implement the function <code>sexpr_of_ntree</code> described below.</li><li>Implement a function that takes as input S-expressions that represent dune files, addes dependencies to the <code>libraries</code> part of the S-expression, and then prints out the updated dune file.</li><li>Implement a function <code>json_of_ntree</code> so that you can convert S-expressions to JSON.</li><li>Implement a function which converts an S-expression into an arithmetic expression (if it has the right form) as the basis of a calculator with LISP-like input syntax.</li></ul><p><em>The point is:</em> once you can read in and represent heirarchical data, you can start processing and reformatting this data (a very common task).</p><div class="odoc-spec"><div class="spec value anchored" id="val-sexpr_of_ntree"><a href="#val-sexpr_of_ntree" class="anchor"></a><code><span><span class="keyword">val</span> sexpr_of_ntree : <span><span>string <a href="../Stdlib320/index.html#type-ntree">Stdlib320.ntree</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>sexpr_of_ntree t</code> is <code>t</code> given as an S-expression. Up to formatting and the <code>Some</code> constructor, it is the inverse of <code>parse</code> on well-formed S-expressions.</p></div></div></div></body></html>
