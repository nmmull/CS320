<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign2 (Spring-2025.Specifications.Assign2)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign2</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign2</span></code></h1><p>This assignment is due on <b>Thursday 2/6 by 8:00PM</b>. You should put all of your solutions in a file called <code>assign2/lib/assign2.ml</code>. See the file <code>test/test_assign2.ml</code> for example behavior of each function.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#programming">Programming</a><ul><li><a href="#practice-problems-(ungraded)">Practice Problems (Ungraded)</a></li><li><a href="#integers-or-strings">Integers or Strings</a></li><li><a href="#recipes-by-ingredients">Recipes by Ingredients</a></li><li><a href="#memory-allocator">Memory Allocator</a></li></ul></li><li><a href="#written">Written</a><ul><li><a href="#typing-in-ocaml-(1)">Typing in OCaml (1)</a></li><li><a href="#typing-in-ocaml-(2)">Typing in OCaml (2)</a></li><li><a href="#for-loops">For Loops</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="programming"><a href="#programming" class="anchor"></a>Programming</h2><h3 id="practice-problems-(ungraded)"><a href="#practice-problems-(ungraded)" class="anchor"></a>Practice Problems (Ungraded)</h3><p>These problems come from a list of <a href="https://ocaml.org/exercises">Exercises</a> on OCaml's webpage. We won't grade these (the solutions are given with the problem statements).</p><ul><li><a href="https://ocaml.org/exercises#6">Palindrome</a></li><li><a href="https://ocaml.org/exercises#10">Run-Length Encoding</a></li><li><a href="https://ocaml.org/exercises#13">Run-Length Encoding of a List (Direct Solution)</a></li><li><a href="https://ocaml.org/exercises#15">Replicate the Elements of a List a Given Number of Times</a></li></ul><h3 id="integers-or-strings"><a href="#integers-or-strings" class="anchor"></a>Integers or Strings</h3><div class="odoc-spec"><div class="spec type anchored" id="type-int_list_or_string_list"><a href="#type-int_list_or_string_list" class="anchor"></a><code><span><span class="keyword">type</span> int_list_or_string_list</span><span> = </span></code><ol><li id="type-int_list_or_string_list.IntList" class="def variant constructor anchored"><a href="#type-int_list_or_string_list.IntList" class="anchor"></a><code><span>| </span><span><span class="constructor">IntList</span> <span class="keyword">of</span> <span>int list</span></span></code></li><li id="type-int_list_or_string_list.StringList" class="def variant constructor anchored"><a href="#type-int_list_or_string_list.StringList" class="anchor"></a><code><span>| </span><span><span class="constructor">StringList</span> <span class="keyword">of</span> <span>string list</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-int_or_string"><a href="#type-int_or_string" class="anchor"></a><code><span><span class="keyword">type</span> int_or_string</span><span> = </span></code><ol><li id="type-int_or_string.Int" class="def variant constructor anchored"><a href="#type-int_or_string.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span> <span class="keyword">of</span> int</span></code></li><li id="type-int_or_string.String" class="def variant constructor anchored"><a href="#type-int_or_string.String" class="anchor"></a><code><span>| </span><span><span class="constructor">String</span> <span class="keyword">of</span> string</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-convert"><a href="#val-convert" class="anchor"></a><code><span><span class="keyword">val</span> convert : <span><span><a href="#type-int_or_string">int_or_string</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-int_list_or_string_list">int_list_or_string_list</a> list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>convert</code> so that <code>convert l</code> is an <code>int_list_or_string_list list</code> in which adjacent <code>string</code> values and <code>int</code> values are grouped together. <b>Important.</b> Make sure to include the definitions of <code>int_or_string</code> and <code>int_list_or_string_list</code> in your solution.</p></div></div><h3 id="recipes-by-ingredients"><a href="#recipes-by-ingredients" class="anchor"></a>Recipes by Ingredients</h3><div class="odoc-spec"><div class="spec type anchored" id="type-recipe"><a href="#type-recipe" class="anchor"></a><code><span><span class="keyword">type</span> recipe</span><span> = </span><span>{</span></code><ol><li id="type-recipe.name" class="def record field anchored"><a href="#type-recipe.name" class="anchor"></a><code><span>name : string;</span></code></li><li id="type-recipe.ingrs" class="def record field anchored"><a href="#type-recipe.ingrs" class="anchor"></a><code><span>ingrs : <span>string list</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-recipes_by_ingrs"><a href="#val-recipes_by_ingrs" class="anchor"></a><code><span><span class="keyword">val</span> recipes_by_ingrs : <span><span><a href="#type-recipe">recipe</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-recipe">recipe</a> list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>recipes_by_ingrs</code> such that <code>recipes_by_ingrs recs ingrs</code> is the sublist of recipes from <code>recs</code> (preserving their order in <code>recs</code>) whose ingredients are entirely included in <code>ingrs</code>. <b>Important.</b> Make sure to include the definition of <code>recipe</code> in your solution.</p></div></div><h3 id="memory-allocator"><a href="#memory-allocator" class="anchor"></a>Memory Allocator</h3><div class="odoc-spec"><div class="spec type anchored" id="type-mem_status"><a href="#type-mem_status" class="anchor"></a><code><span><span class="keyword">type</span> mem_status</span><span> = </span></code><ol><li id="type-mem_status.Free" class="def variant constructor anchored"><a href="#type-mem_status.Free" class="anchor"></a><code><span>| </span><span><span class="constructor">Free</span></span></code></li><li id="type-mem_status.Occupied" class="def variant constructor anchored"><a href="#type-mem_status.Occupied" class="anchor"></a><code><span>| </span><span><span class="constructor">Occupied</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-memory"><a href="#type-memory" class="anchor"></a><code><span><span class="keyword">type</span> memory</span><span> = <span><span>(<a href="#type-mem_status">mem_status</a> * int)</span> list</span></span></code></div></div><p>In this problem, you will be building an allocator for a very simple model of (unlimited) memory. In this model, we represent memory as a list of pairs of values, each representing a chunk of memory. The first entry of the pair tells us if the chunk is <code>Free</code> or <code>Occupied</code>, and the second tells us how many units of memory the chunk occupies. Furthermore, we require that memory has the following properties:</p><ul><li>There are no adjacent <code>Free</code> chunks of memory (there may be adjacent chunks of <code>Occupied</code> memory)</li><li>There is no <code>Free</code> chunk of memory at the end of the list, i.e., either the list is empty or the last element is an <code>Occupied</code> block.</li></ul><p>For example, the list:</p><pre class="language-ocaml"><code>[Free 3; Occupied 1; Occupied 3; Free 2; Occupied 1]</code></pre><p>would represent the layout:</p><pre class="language-text"><code>Status:   | F | F | F | O | O | O | O | F | F | O | F | F | ...
Position: 0   1   2   3   4   5   6   7   8   9   10  11  12...</code></pre><p>Note that positions do not correspond to indices of chunks in the list.</p><p>You will be implementing two functions. The function <code>allocate</code> allocates memory by placing an <code>Occupied</code> chunk of memory in the <i>leftmost</i> available position. It's possible to allocate a chunk of memory at position <code>i</code> of size <code>size</code> if the positions <code>i</code>, <code>i + 1</code>, ..., <code>i + size - 1</code> are <code>Free</code>. After allocation, these positions become <code>Occupied</code>. In the above example, it should be possible to allocate a chunk of memory of size <code>2</code> at position <code>0</code> giving us the list:</p><pre class="language-ocaml"><code>[Occupied 2; Free 1; Occupied 1; Occupied 3; Free 2; Occupied 1]</code></pre><p>whereas the leftmost place to allocate a chunk of memory of size <code>5</code> is at position <code>10</code>, giving us the list:</p><pre class="language-ocaml"><code>[Free 3; Occupied 1; Occupied 3; Free 2; Occupied 1; Occupied 5]</code></pre><p>The second function <code>free</code> should make an <code>Occupied</code> block of memory into a <code>Free</code> block, given its position. In addition it <b>must</b> maintain the invariants described above.</p><div class="odoc-spec"><div class="spec type anchored" id="type-alloc_result"><a href="#type-alloc_result" class="anchor"></a><code><span><span class="keyword">type</span> alloc_result</span><span> = </span></code><ol><li id="type-alloc_result.Success" class="def variant constructor anchored"><a href="#type-alloc_result.Success" class="anchor"></a><code><span>| </span><span><span class="constructor">Success</span> <span class="keyword">of</span> int * <a href="#type-memory">memory</a></span></code></li><li id="type-alloc_result.Invalid_size" class="def variant constructor anchored"><a href="#type-alloc_result.Invalid_size" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_size</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-allocate"><a href="#val-allocate" class="anchor"></a><code><span><span class="keyword">val</span> allocate : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-alloc_result">alloc_result</a></span></code></div><div class="spec-doc"><p>Implement the function <code>allocate</code> so that <code>allocate size mem</code> is an <code>alloc_result</code> according to the following allocation strategy:</p><ul><li>If <code>size</code> is not positive, then it is invalid.</li><li>Otherwise, <code>allocate size mem</code> should be the same as <code>mem</code> except with an <code>Occupied</code> chuck of memory of size <code>size</code> in the <i>leftmost</i> possible position, together with the position itself.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-free_result"><a href="#type-free_result" class="anchor"></a><code><span><span class="keyword">type</span> free_result</span><span> = </span></code><ol><li id="type-free_result.Success" class="def variant constructor anchored"><a href="#type-free_result.Success" class="anchor"></a><code><span>| </span><span><span class="constructor">Success</span> <span class="keyword">of</span> <a href="#type-memory">memory</a></span></code></li><li id="type-free_result.Invalid_position" class="def variant constructor anchored"><a href="#type-free_result.Invalid_position" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_position</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-free"><a href="#val-free" class="anchor"></a><code><span><span class="keyword">val</span> free : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-free_result">free_result</a></span></code></div><div class="spec-doc"><p>Implement the function <code>free</code> so that <code>free pos mem</code> is a <code>free_result</code> such that:</p><ul><li>If <code>pos</code> is negative, or is not the beginning of an <code>Occupied</code> chunk of memory, then the position is invalid</li><li>The chunk starting at <code>pos</code> in <code>mem</code> should be converted to a <code>Free</code> block and the result should be updated to maintain the above invariants (no adjacent <code>Free</code> chunks, no ending <code>Free</code> chunks.</li></ul></div></div><h2 id="written"><a href="#written" class="anchor"></a>Written</h2><h3 id="typing-in-ocaml-(1)"><a href="#typing-in-ocaml-(1)" class="anchor"></a>Typing in OCaml (1)</h3><div><pre class="odoc-katex-math display">   \{ \texttt{z} : \texttt{int} \} \vdash \texttt{fun x -&gt; fun y -&gt; x y z + y z + z} : \tau
   </pre></div><p>Is there a type <code class="odoc-katex-math">\tau</code> such that the above typing judgment holds in OCaml? If so, determine the type. If not, justify your answer.</p><h3 id="typing-in-ocaml-(2)"><a href="#typing-in-ocaml-(2)" class="anchor"></a>Typing in OCaml (2)</h3><div><pre class="odoc-katex-math display">   \{ \texttt{g} : \texttt{int -&gt; bool} \} \vdash \texttt{let rec f x = g (f (x + 1))} : \tau
   </pre></div><p>Is there a type <code class="odoc-katex-math">\tau</code> such that the above typing judgment holds in OCaml? If so, determine the type. If not, justify your answer.</p><h3 id="for-loops"><a href="#for-loops" class="anchor"></a>For Loops</h3><p>Suppose you're interested in adding a kind of functional for-loop into an OCaml-like language. You decide on the syntax</p><pre class="language-ocaml"><code>&lt;expr&gt; ::= repeat &lt;expr&gt; times &lt;expr&gt; from &lt;expr&gt;</code></pre><p>That is, if <code class="odoc-katex-math">e_1</code>, <code class="odoc-katex-math">e_2</code>, and <code class="odoc-katex-math">e_3</code> are well-formed expressions, then so is</p><div><pre class="odoc-katex-math display">   \texttt{repeat} \ e_1 \ \texttt{times} \ e_2 \ \texttt{from} \ e_3
   </pre></div><p>The hope is that you can write code like</p><pre class="language-ocaml"><code>let fact n =
  let loop =
    repeat n times
      let (i, m) = acc in
      (i + 1, m * i)
    from
      (1, 1)
  in let (_, out) = loop in out</code></pre><p>or even:</p><pre class="language-ocaml"><code>let fact n =
  let loop =
    repeat n times
      { i = acc.i + 1; out = acc.out * acc.i }
    from
      { i = 1; out = 1 }
  in loop.out</code></pre><p>Intuitively, we need to requires in <code>repeat n times e1 from e2</code> that <code>n</code> is an <code>int</code> and the <code>e1</code> and <code>e2</code> have the same type. Furthermore we require that <code>e1</code> is well-typed a context which <b>includes a variable <code>acc</code> which is the same type as that of <code>e1</code> and <code>e2</code></b>.</p><p>In English, the typing rule for this new construct is as follows: if <code class="odoc-katex-math">e_1</code> is of type <code>int</code> in the context <code class="odoc-katex-math">\Gamma</code>, and <code class="odoc-katex-math">e_2</code> is of type <code class="odoc-katex-math">\tau</code> in the context <code class="odoc-katex-math">\Gamma</code> with the additional declaration that the variable <code class="odoc-katex-math">acc</code> is of type <code class="odoc-katex-math">\tau</code>, and <code class="odoc-katex-math">e_3</code> is of type <code class="odoc-katex-math">\tau</code> in the context <code class="odoc-katex-math">\Gamma</code>, then <code class="odoc-katex-math">\texttt{repeat} \ e_1 \ \texttt{times} \ e_2 \ \texttt{from} \ e_3</code> is of type <code class="odoc-katex-math">\tau</code>.</p><p>Write this typing rule as a formal inference rule.</p></div></body></html>
