<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign6 (Spring-2025.Specifications.Assign6)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Spring-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign6</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign6</span></code></h1><p>This assignment is due on <b>Thursday 3/20 by 8:00PM</b>. You should put all of your solutions in <code>assign6/lib/assign6.ml</code>. See the file <code>test/test_assign6.ml</code> for example behavior of each function.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#programming">Programming</a><ul><li><a href="#problem-1:-parsing">Problem 1: Parsing</a></li><li><a href="#problem-2:-type-checking">Problem 2: Type-Checking</a></li><li><a href="#problem-3:-evaluating">Problem 3: Evaluating</a></li></ul></li><li><a href="#the-executable">The Executable</a></li><li><a href="#written">Written</a><ul><li><a href="#ambiguity">Ambiguity</a></li><li><a href="#designing-grammars">Designing Grammars</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="programming"><a href="#programming" class="anchor"></a>Programming</h2><p>The purpose of this assignment is to give you a taste of the mini-projects by building an S-expressions calculator. Here is a simple example of an expression in this language.</p><pre class="language-ocaml"><code>(?
  (&lt; (+ 2 3) (+ 3 3))
  0
  (+ 1 1))</code></pre><p>This expression has type <code class="odoc-katex-math">\texttt{int}</code> and evaluates to <code class="odoc-katex-math">\texttt{0}</code>.</p><p>In more familiar OCaml-like syntax, this would look like:</p><pre class="language-ocaml"><code>if 2 + 3 &lt; 3 + 3 then 0 else 1 + 1</code></pre><p>In the mini-projects, you'll be given three things: syntax, typing rules, and semantics. It will then be your task to implement an interpreter. <i>Note that several of the parts below require little to no new code.</i></p><p>Here's the syntax of our toy language.</p><div><pre class="odoc-katex-math display">    \begin{align*}
      \textcolor{blue}{\texttt{&lt;expr&gt;}} &amp;::= \textcolor{blue}{\texttt{&lt;int&gt;}} \\
      &amp;\hspace{3mm}| \hspace{2.5mm} \textcolor{red}{\texttt{(}} \ \textcolor{red}{\texttt{+}} \ \textcolor{blue}{\texttt{&lt;expr&gt;}} \ \textcolor{blue}{\texttt{&lt;expr&gt;}} \ \textcolor{red}{\texttt{)}} \\
      &amp;\hspace{3mm}| \hspace{2.5mm} \textcolor{red}{\texttt{(}} \ \textcolor{red}{\texttt{&lt;}} \ \textcolor{blue}{\texttt{&lt;expr&gt;}} \ \textcolor{blue}{\texttt{&lt;expr&gt;}} \ \textcolor{red}{\texttt{)}} \\
      &amp;\hspace{3mm}| \hspace{2.5mm} \textcolor{red}{\texttt{(}} \ \textcolor{red}{\texttt{?}} \ \textcolor{blue}{\texttt{&lt;expr&gt;}} \ \textcolor{blue}{\texttt{&lt;expr&gt;}} \ \textcolor{blue}{\texttt{&lt;expr&gt;}} \ \textcolor{red}{\texttt{)}} \\
    \end{align*}
    </pre></div><p>Next, the typing rules. Expressions can either be integers or Boolean values. These should feel familiar. We'll elide names because we won't be writing derivations for this system. Note that there is no need for a context because there are no local variables!</p><div><pre class="odoc-katex-math display">
    \frac
    {n \text{ is an integer literal}}
    {n : \texttt{int}}
    \qquad
    \frac
    {e_1 : \texttt{int}
     \qquad
     e_2 : \texttt{int}
    }
    {\texttt{(} \ \texttt{+} \ e_1 \ e_2 \ \texttt{)} : \texttt{int}}
    \qquad
    \frac
    {e_1 : \texttt{int}
     \qquad
     e_2 : \texttt{int}
    }
    {\texttt{(} \ \texttt{&lt;} \ e_1 \ e_2 \ \texttt{)} : \texttt{bool}}
    \qquad
    \frac
    {e_1 : \texttt{bool}
     \qquad
     e_2 : \tau
     \qquad
     e_3 : \tau
    }
    {\texttt{(} \ \texttt{?} \ e_1 \ e_2 \ e_3 \ \texttt{)} : \tau}
    </pre></div><p>Finally, the semantics. These should also feel familiar.</p><div><pre class="odoc-katex-math display">    \frac
    {n \text{ is an integer literal}}
    {n \Downarrow n}
    \qquad
    \frac
    {e_1 \Downarrow v_1 \qquad e_2 \Downarrow v_2 \qquad v_1 + v_2 = v}
    {\texttt{(} \ \texttt{+} \ e_1 \ e_2 \ \texttt{)} \Downarrow v}
    \qquad
    \frac
    {e_1 \Downarrow v_1 \qquad e_2 \Downarrow v_2 \qquad v_1 &lt; v_2}
    {\texttt{(} \ \texttt{&lt;} \ e_1 \ e_2 \ \texttt{)} \Downarrow \top}
    </pre></div><div><pre class="odoc-katex-math display">    \frac
    {e_1 \Downarrow v_1 \qquad e_2 \Downarrow v_2 \qquad v_1 \geq v_2}
    {\texttt{(} \ \texttt{&lt;} \ e_1 \ e_2 \ \texttt{)} \Downarrow \bot}
    \qquad
    \frac
    {e_1 \Downarrow \top \qquad e_2 \Downarrow v_2}
    {\texttt{(} \ \texttt{?} \ e_1 \ e_2 \ e_3 \ \texttt{)} \Downarrow v_2}
    \qquad
    \frac
    {e_1 \Downarrow \bot \qquad e_3 \Downarrow v_3}
    {\texttt{(} \ \texttt{?} \ e_1 \ e_2 \ e_3 \ \texttt{)} \Downarrow v_3}
    </pre></div><h3 id="problem-1:-parsing"><a href="#problem-1:-parsing" class="anchor"></a>Problem 1: Parsing</h3><p>In rough terms, lexing (or tokenizing) is the process of converting a string into a list of <i>tokens</i>. Tokens are the <i>abstract units</i> of a programming language. We convert our input program (a string) into a list of tokens so that we don't need to deal with low-level concerns like whitespace when parsing. You're given an implementation of a lexer.</p><div class="odoc-spec"><div class="spec type anchored" id="type-tok"><a href="#type-tok" class="anchor"></a><code><span><span class="keyword">type</span> tok</span><span> = </span></code><ol><li id="type-tok.LParen" class="def variant constructor anchored"><a href="#type-tok.LParen" class="anchor"></a><code><span>| </span><span><span class="constructor">LParen</span></span></code></li><li id="type-tok.RParen" class="def variant constructor anchored"><a href="#type-tok.RParen" class="anchor"></a><code><span>| </span><span><span class="constructor">RParen</span></span></code></li><li id="type-tok.TNum" class="def variant constructor anchored"><a href="#type-tok.TNum" class="anchor"></a><code><span>| </span><span><span class="constructor">TNum</span> <span class="keyword">of</span> int</span></code></li><li id="type-tok.TAdd" class="def variant constructor anchored"><a href="#type-tok.TAdd" class="anchor"></a><code><span>| </span><span><span class="constructor">TAdd</span></span></code></li><li id="type-tok.TLt" class="def variant constructor anchored"><a href="#type-tok.TLt" class="anchor"></a><code><span>| </span><span><span class="constructor">TLt</span></span></code></li><li id="type-tok.TIf" class="def variant constructor anchored"><a href="#type-tok.TIf" class="anchor"></a><code><span>| </span><span><span class="constructor">TIf</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lex"><a href="#val-lex" class="anchor"></a><code><span><span class="keyword">val</span> lex : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-tok">tok</a> list</span> option</span></span></code></div><div class="spec-doc"><p><code>lex s</code> is <code>Some tks</code> where <code>tks</code> is the list of tokens representing <code>s</code> and <code>None</code> otherwise. It's a variant of <code>tokenize</code> from Lab 4, which you can check for more details.</p><p>We'll use an ADT to represent expressions in our language, similar to previous assignments.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.Num" class="def variant constructor anchored"><a href="#type-expr.Num" class="anchor"></a><code><span>| </span><span><span class="constructor">Num</span> <span class="keyword">of</span> int</span></code></li><li id="type-expr.Add" class="def variant constructor anchored"><a href="#type-expr.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.Lt" class="def variant constructor anchored"><a href="#type-expr.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.If" class="def variant constructor anchored"><a href="#type-expr.If" class="anchor"></a><code><span>| </span><span><span class="constructor">If</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>parse</code> so that <code>parse str</code> is</p><ul><li><code>Some e</code> if <code>str</code> represents a well-formed program;</li><li><code>None</code> otherwise.</li></ul><p>You've already built a parser for S-expressions in Lab 4. Repurpose that code to work for this new <code>expr</code> ADT (as opposed to nonempty trees) and compose it with the given function <code>lex</code>.</p></div></div><h3 id="problem-2:-type-checking"><a href="#problem-2:-type-checking" class="anchor"></a>Problem 2: Type-Checking</h3><div class="odoc-spec"><div class="spec type anchored" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span><span class="keyword">type</span> ty</span><span> = </span></code><ol><li id="type-ty.TInt" class="def variant constructor anchored"><a href="#type-ty.TInt" class="anchor"></a><code><span>| </span><span><span class="constructor">TInt</span></span></code></li><li id="type-ty.TBool" class="def variant constructor anchored"><a href="#type-ty.TBool" class="anchor"></a><code><span>| </span><span><span class="constructor">TBool</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_of"><a href="#val-type_of" class="anchor"></a><code><span><span class="keyword">val</span> type_of : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ty">ty</a> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>type_of</code> so that <code>type_of e</code> is</p><ul><li><code>Some t</code> where <code>t</code> is the type of <code>e</code> if <code>e</code> is well-typed;</li><li><code>None</code> otherwise.</li></ul><p>An expression <code class="odoc-katex-math">e</code> is well-typed if if <code class="odoc-katex-math">e : \tau</code> is derivable according to the above typing rules for some type <code class="odoc-katex-math">\tau</code>.</p></div></div><h3 id="problem-3:-evaluating"><a href="#problem-3:-evaluating" class="anchor"></a>Problem 3: Evaluating</h3><div class="odoc-spec"><div class="spec type anchored" id="type-value"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> value</span><span> = </span></code><ol><li id="type-value.VNum" class="def variant constructor anchored"><a href="#type-value.VNum" class="anchor"></a><code><span>| </span><span><span class="constructor">VNum</span> <span class="keyword">of</span> int</span></code></li><li id="type-value.VBool" class="def variant constructor anchored"><a href="#type-value.VBool" class="anchor"></a><code><span>| </span><span><span class="constructor">VBool</span> <span class="keyword">of</span> bool</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span><span class="keyword">val</span> eval : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-value">value</a></span></code></div><div class="spec-doc"><p>Implement the function <code>eval</code> so that <code>eval e</code> is <code>v</code> is the value of <code>e</code> given that <code>e</code> is well-typed. The behavior of the implementation is undefined if <code>e</code> is not well-typed (i.e., if <code>type_of e</code> is <code>None</code>).</p></div></div><h2 id="the-executable"><a href="#the-executable" class="anchor"></a>The Executable</h2><p>Once you've finished the above problems, you can run your interpreter on an actual program. There are several example programs in the directory <code>examples</code>. If you've done everything correctly, you should be able to run the command</p><pre class="language-ocaml"><code>dune exec assign6 examples/file_name</code></pre><p>(replace <code>file_name</code> with the name of one of the files in that directory) which will print out the value of the expression in the file. You can even write your own programs if you'd like.</p><p>To be clear, there are no tasks for the assignment in this section, this is just for fun. That said, <b>please look through the file <code>bin/main.ml</code>.</b> This file chains together the lexer, parser, type checker, and evaluator. In the future, we will be asking you to write this part.</p><h2 id="written"><a href="#written" class="anchor"></a>Written</h2><h3 id="ambiguity"><a href="#ambiguity" class="anchor"></a>Ambiguity</h3><pre class="language-text"><code>&lt;s&gt; ::= A &lt;s&gt; B
      | &lt;a&gt;
&lt;a&gt; ::= A &lt;a&gt;
      | B &lt;b&gt;
&lt;b&gt; ::= B B &lt;b&gt;
      | B B</code></pre><p>Determine a sentence <i>with fewer than 8 symbols</i> which has two distinct leftmost derivations in the above grammar. Also write down these two leftmost derivations.</p><h3 id="designing-grammars"><a href="#designing-grammars" class="anchor"></a>Designing Grammars</h3><p>Write down a grammar over the terminal symbols <code>A</code> and <code>B</code> such that every sentence recognized by the grammar is any number of <code>A</code>s, followed by a sequence of at least 2 <code>B</code>s. For example <code>AAAABBB</code>, <code>BBB</code>, and <code>AABB</code> should be sentences recognized by the grammar, whereas <code>AAAB</code>, <code>AB</code>, and <code>A</code> should not. You may introduce any nonterminal symbols that you want.</p></div></body></html>
