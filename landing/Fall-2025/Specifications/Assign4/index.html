<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign4 (Fall-2025.Specifications.Assign4)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Fall-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign4</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign4</span></code></h1><p>This assignment is due on <b>Thursday 10/2 by 8:00PM</b>. You should put all of your programming solutions in a file called <code>assign4/lib/assign4.ml</code>. See the file <code>test/test_assign4.ml</code> for example behavior of each function. You should put all your written solutions in a single pdf file.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#programming-(100%)">Programming (100%)</a><ul><li><a href="#parsing-s-expressions">Parsing S-expressions</a></li><li><a href="#parsing-arithmetic-expression">Parsing Arithmetic Expression</a></li><li><a href="#evaluating-arithmetic-expressions">Evaluating Arithmetic Expressions</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="programming-(100%)"><a href="#programming-(100%)" class="anchor"></a>Programming (100%)</h2><h3 id="parsing-s-expressions"><a href="#parsing-s-expressions" class="anchor"></a>Parsing S-expressions</h3><div class="odoc-spec"><div class="spec type anchored" id="type-sexpr"><a href="#type-sexpr" class="anchor"></a><code><span><span class="keyword">type</span> sexpr</span><span> = </span></code><ol><li id="type-sexpr.Atom" class="def variant constructor anchored"><a href="#type-sexpr.Atom" class="anchor"></a><code><span>| </span><span><span class="constructor">Atom</span> <span class="keyword">of</span> string</span></code></li><li id="type-sexpr.List" class="def variant constructor anchored"><a href="#type-sexpr.List" class="anchor"></a><code><span>| </span><span><span class="constructor">List</span> <span class="keyword">of</span> <span><a href="#type-sexpr">sexpr</a> list</span></span></code></li></ol></div></div><p>An <b>S-expression</b> is one of two things:</p><ul><li>an <b>atom</b>, which we will take to be any nonempty sequence of non-whitespace-non-parentheses characters;</li><li>an expression of the form <code class="odoc-katex-math">\texttt( e_1 \ \dots \ e_k \texttt)</code>, where <code class="odoc-katex-math">e_1</code> through <code class="odoc-katex-math">e_k</code> are S-expressions.</li></ul><p>Recursive algebraic data types are perfect for representing S-expressions. <code>(+ (/ 1 2) (- 3 4))</code> is a simple S-expression which would be represented as the following value of the above ADT.</p><pre class="language-ocaml"><code>  List
    [
      Atom &quot;+&quot;;
      List [Atom &quot;/&quot;; Atom &quot;1&quot;; Atom &quot;2&quot;];
      List [Atom &quot;-&quot;; Atom &quot;3&quot;; Atom &quot;4&quot;];
    ]</code></pre><p>S-expressions are used for the surface syntax of several programming languages, primarily LISP dialects like Racket. This is how we will be using them in this assignment. They also offer a simple alternative to human-readable data-interchange formats like XML and JSON. <code>dune</code> files, for example, are S-expression; take a look at <code>assign4/lib/dune</code>.</p><p>The key feature of S-expressions is that they are <i>hierarchical</i>, whereas text on it's own is flat. Parsing an S-expression means converting a string representing a S-expression into an <code>sexpr</code> as defined above. This is easier to do if we ignore low level concerns like whitespace; this is the purpose of <b>lexical analysis</b> or <b>tokenizing</b>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-token"><a href="#type-token" class="anchor"></a><code><span><span class="keyword">type</span> token</span><span> = </span></code><ol><li id="type-token.Lparen" class="def variant constructor anchored"><a href="#type-token.Lparen" class="anchor"></a><code><span>| </span><span><span class="constructor">Lparen</span></span></code></li><li id="type-token.Rparen" class="def variant constructor anchored"><a href="#type-token.Rparen" class="anchor"></a><code><span>| </span><span><span class="constructor">Rparen</span></span></code></li><li id="type-token.Atom" class="def variant constructor anchored"><a href="#type-token.Atom" class="anchor"></a><code><span>| </span><span><span class="constructor">Atom</span> <span class="keyword">of</span> string</span></code></li></ol></div></div><p>We've implemented lexing for you in the starter code under the name <code>tokens_of_string</code>. The example above as tokens becomes</p><pre class="language-ocaml"><code>  [
    Lparen;
      Atom &quot;+&quot;;
      Lparen; Atom &quot;/&quot;; Atom &quot;1&quot;; Atom &quot;2&quot;; Rparen;
      Lparen; Atom &quot;-&quot;; Atom &quot;3&quot;; Atom &quot;4&quot;; Rparen;
    Rparen;
  ]</code></pre><div class="odoc-spec"><div class="spec value anchored" id="val-sexpr_of_tokens"><a href="#val-sexpr_of_tokens" class="anchor"></a><code><span><span class="keyword">val</span> sexpr_of_tokens : <span><span><a href="#type-token">token</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-sexpr">sexpr</a> * <span><a href="#type-token">token</a> list</span>)</span> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>sexpr_of_tokens</code> so that <code>sexpr_of_tokens toks</code> is</p><ul><li><code>Some (e, rest)</code> if <code>toks</code> has a prefix <code>pre</code> that represents the S-expression <code>e</code> and <code>pre @ rest = toks</code></li><li><code>None</code> otherwise.</li></ul><p>This function should depend on <code>sexprs_of_tokens</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexprs_of_tokens"><a href="#val-sexprs_of_tokens" class="anchor"></a><code><span><span class="keyword">val</span> sexprs_of_tokens : <span><span><a href="#type-token">token</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-sexpr">sexpr</a> list</span> * <span><a href="#type-token">token</a> list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>sexprs_of_tokens</code> so that <code>sexprs_of_tokens toks</code> is <code>(es, rest)</code> where <code>toks</code> as a <i>maximal</i> prefix <code>pre</code> that represents <i>a list</i> of S-expressions, and <code>pre @ rest = toks</code>. Note there is no need for <code>option</code> here; if there is no S-expression at the beginning of <code>toks</code> then the output should be <code>([], toks)</code>.</p><p>This functions should depend on <code>sexpr_of_tokens</code> (yes, they're mutually recursive).</p><p><b>Hint:</b> The challenge with mutual recursion is convincing yourself that it works. I always recommend: don't think about it too hard. <i>Assume</i> that both functions work as they are supposed to, and then implement them under this assumption.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse_sexpr"><a href="#val-parse_sexpr" class="anchor"></a><code><span><span class="keyword">val</span> parse_sexpr : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-sexpr">sexpr</a> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>parse_sexpr</code> so that <code>parse_sexpr s</code> is <code>Some e</code> if <code>s</code> represents the S-expression <code>e</code>, and <code>None</code> otherwise. <b>Hint:</b> This should be one match using previously defined functions.</p></div></div><h3 id="parsing-arithmetic-expression"><a href="#parsing-arithmetic-expression" class="anchor"></a>Parsing Arithmetic Expression</h3><p>We can also use ADTs to represent arithmetic expressions.</p><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.Int" class="def variant constructor anchored"><a href="#type-expr.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span> <span class="keyword">of</span> int</span></code></li><li id="type-expr.Add" class="def variant constructor anchored"><a href="#type-expr.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.Sub" class="def variant constructor anchored"><a href="#type-expr.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.Mul" class="def variant constructor anchored"><a href="#type-expr.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.Div" class="def variant constructor anchored"><a href="#type-expr.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li></ol></div></div><p>The example above, which can be written in more familiar infix notation as <code>(1 / 2) + (3 * 4)</code>, is represented by the following value of the above ADT.</p><pre class="language-ocaml"><code>  Add
    ( Div (Int 1, Int 2)
    , Mul (Int 3, Int 4)
    )</code></pre><p>Like with parsing S-expressions, the hard part of parsing arithemtic expressions is getting the <i>heirarchical</i> structure of the expression from the flat string representation. But once we have a parse for S-expressions, we have a parser for any programming language (even one for humble arithmetic expressions) which uses S-expressions as a surface language. All we have to do is convert between the two representations.</p><div class="odoc-spec"><div class="spec value anchored" id="val-expr_of_sexpr"><a href="#val-expr_of_sexpr" class="anchor"></a><code><span><span class="keyword">val</span> expr_of_sexpr : <span><a href="#type-sexpr">sexpr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>expr_of_sexpr</code> so that <code>expr_of_sexpr se</code> is <code>Some e</code> if <code>se</code> represents the arithmetic expression <code>e</code>, and <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>parse</code> so that <code>parse s</code> is <code>Some e</code> is <code>s</code> represents the arithmetic expression <code>e</code>, and <code>None</code> otherwise. <b>Hint:</b> This should just be the composition of parsing an S-expression and converting it into an arithemtic expression, with some <code>option</code> pattern matching in between.</p></div></div><h3 id="evaluating-arithmetic-expressions"><a href="#evaluating-arithmetic-expressions" class="anchor"></a>Evaluating Arithmetic Expressions</h3><p>Once we have an ADT for arithmetic expressions, we can evaluate them. The evaluation rules for arithemtic expressions are as follows.</p><div><pre class="odoc-katex-math display">    \frac
    {\texttt{n} \text{ is an integer literal for } n}
    {\texttt{n} \Downarrow n}
    \text{(intEval)}
    \qquad
    \frac
    {e_1 \Downarrow v_1 \quad e_2 \Downarrow v_2 \quad v = v_1 + v_2}
    {\texttt{( + } e_1 \ e_2 \texttt{ )} \Downarrow v}
    \text{(addEval)}
    \qquad
    \frac
    {e_1 \Downarrow v_1 \quad e_2 \Downarrow v_2 \quad v = v_1 - v_2}
    {\texttt{( - } e_1 \ e_2 \texttt{ )} \Downarrow v}
    \text{(subEval)}
    </pre></div><div><pre class="odoc-katex-math display">    \frac
    {e_1 \Downarrow v_1 \quad e_2 \Downarrow v_2 \quad v = v_1 v_2}
    {\texttt{( * } e_1 \ e_2 \texttt{ )} \Downarrow v}
    \text{(mulEval)}
    \qquad
    \frac
    {e_1 \Downarrow v_1 \quad e_2 \Downarrow v_2 \quad v_2 \neq 0 \quad v = v_1 / v_2}
    {\texttt{( / } e_1 \ e_2 \texttt{ )} \Downarrow v}
    \text{(divEval)}
    </pre></div><p>where &quot;<code class="odoc-katex-math">/</code>&quot; is integer division.</p><div class="odoc-spec"><div class="spec value anchored" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span><span class="keyword">val</span> eval : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Implement the function <code>eval</code> so that <code>eval e</code> is the result of evaluating <code>e</code> according to the above rules. That is, if <code class="odoc-katex-math">e \Downarrow v</code>, then <code>eval</code> <code class="odoc-katex-math">e</code> should be <code class="odoc-katex-math">v</code>. Your function should raise a <code>Division_by_zero</code> exception in the case that there is a division by zero in <code>e</code> (you don't need to do anything for this, integer division does this already).</p><p>This is not a complicated function. The point is to recognize that there is a tight correspondence between the evaluation rules and implementation of an evaluator.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interp"><a href="#val-interp" class="anchor"></a><code><span><span class="keyword">val</span> interp : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>interp</code> so that <code>interp s</code> is <code>Some (eval e)</code> if <code>s</code> represents an arithmetic expression <code>e</code>, and <code>None</code> otherwise.</p></div></div></div></body></html>
