<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign2 (Fall-2025.Specifications.Assign2)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Fall-2025</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign2</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign2</span></code></h1><p>This assignment is due on <b>Thursday 9/18 by 8:00PM</b>. You should put all of your programming solutions in a file called <code>assign2/lib/assign2.ml</code>. See the file <code>test/test_assign2.ml</code> for example behavior of each function. You should put all your written solutions in a single pdf file.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#programming-(40%)">Programming (40%)</a><ul><li><a href="#practice-problems-(ungraded)">Practice Problems (Ungraded)</a></li><li><a href="#drop-leading/trailing">Drop Leading/Trailing</a></li><li><a href="#split-on-character">Split on Character</a></li><li><a href="#fractran">FRACTRAN</a></li></ul></li><li><a href="#written-(60%)">Written (60%)</a><ul><li><a href="#grammar-rule-to-english">Grammar Rule to English</a></li><li><a href="#typing-judgment-to-english">Typing Judgment to English</a></li><li><a href="#typing-rule-to-english">Typing Rule to English</a></li><li><a href="#typing-judgments-in-ocaml">Typing Judgments in OCaml</a></li><li><a href="#fractran_2">FRACTRAN</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="programming-(40%)"><a href="#programming-(40%)" class="anchor"></a>Programming (40%)</h2><h3 id="practice-problems-(ungraded)"><a href="#practice-problems-(ungraded)" class="anchor"></a>Practice Problems (Ungraded)</h3><p>These problems come from a list of <a href="https://ocaml.org/exercises">Exercises</a> on OCaml's webpage. We won't grade these (the solutions are given with the problem statements) but we'll typically include a couple with each assignment for additional practice.</p><ul><li><a href="https://ocaml.org/exercises#6">Palindrome</a></li><li><a href="https://ocaml.org/exercises#10">Run-Length Encoding</a></li><li><a href="https://ocaml.org/exercises#15">Replicate the Elements of a List a Given Number of Times</a></li></ul><h3 id="drop-leading/trailing"><a href="#drop-leading/trailing" class="anchor"></a>Drop Leading/Trailing</h3><div class="odoc-spec"><div class="spec value anchored" id="val-drop_leading"><a href="#val-drop_leading" class="anchor"></a><code><span><span class="keyword">val</span> drop_leading : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>drop_leading</code> so that <code>drop_leading k l</code> is the result of removing all instances of <code>k</code> from the beginning of the list <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drop_trailing"><a href="#val-drop_trailing" class="anchor"></a><code><span><span class="keyword">val</span> drop_trailing : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p>Also implement the function <code>drop_trailing</code> so that <code>drop_trailing k l</code> is the result of removing all instances of <code>k</code> from the <i>end</i> of the list <code>l</code>. <i>Hint.</i> Don't re-implement the same logic as above, use <code>drop_leading</code> and another common list function.</p></div></div><h3 id="split-on-character"><a href="#split-on-character" class="anchor"></a>Split on Character</h3><div class="odoc-spec"><div class="spec value anchored" id="val-split_on_char"><a href="#val-split_on_char" class="anchor"></a><code><span><span class="keyword">val</span> split_on_char : <span>char <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>split_on_char</code> so that <code>split_on_char sep s</code> is the list of all (possibly empty) substrings of <code>s</code> that are delimited by the character <code>sep</code>. If <code>s</code> is empty, the result is the singleton list <code>[&quot;&quot;]</code> (this description is taken from the OCaml standard library documentation).</p><p><b>Note.</b> Working with strings in OCaml is different from working with lists (in a sense they might seem more familiar if you're coming from a language with arrays). We cannot destruct strings. Rather we use the functions <code>String.get</code> and <code>String.sub</code> to access parts of the string. See the <a href="https://nmmull.github.io/stdlib320/stdlib320/Stdlib320/String/index.html">Standard library documentation on strings</a> for more details.</p></div></div><h3 id="fractran"><a href="#fractran" class="anchor"></a>FRACTRAN</h3><p>In this problem we're going to implement an interpreter for FRACTRAN. Interpreting a FRACTRAN program means working with very large numbers, and integers in OCaml are not arbitrary-precision. Therefore, we begin by installing a library for arbitrary-precision integer arithmetic. In a terminal, run the following:</p><pre class="language-ocaml"><code>eval $(opam env)
opam install zarith</code></pre><p>This library will give us access to two new types: <code>Z.t</code> for arbitrary-precision integers and <code>Q.t</code> for arbitrary-precision rationals. <b>Remember:</b> There is no operator overloading in OCaml. We cannot use the <code>+</code> or <code>*</code> operator on values of these types. We will be clear in each subproblem below which functions you'll want to use in your implementation.</p><div class="odoc-spec"><div class="spec value anchored" id="val-parse_fractran"><a href="#val-parse_fractran" class="anchor"></a><code><span><span class="keyword">val</span> parse_fractran : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Q</span>.t list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>parse_fractran</code> so that <code>parse_fractran s</code> is a FRACTRAN program (i.e., a list of fractions) according to the following rules:</p><ul><li>The input string must be a sequence of fractions in a single line separated by exactly one space.</li><li>A fraction must consist of two integers separated by a single <code>'/'</code> character and no spaces.</li></ul><p>See the example FRACTRAN programs in the given implementations of <code>max_fractran</code> and <code>fib_fractran</code> below. For this problem, we will assume the input is well-formed. In particular, we will consider the behavior of the function undefined otherwise. You'll likely want to use the following functions in your implementation.</p><ul><li><code>Z.of_string s</code> is the arbitrary-precision integer represented by the string <code>s</code>.</li><li><code>Q.make num den</code> is the arbitrary precision fraction with numerator <code>num</code> and denominator <code>den</code>.</li><li><code>List.nth l i</code> is the <code>i</code>th element of <code>l</code> assuming <code>0 &lt;= i</code> and <code>i &lt; List.length l</code>.</li><li><code>split_on_char</code> from the previous problem will also naturally be useful.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_fractran"><a href="#val-eval_fractran" class="anchor"></a><code><span><span class="keyword">val</span> eval_fractran : <span><span><span class="xref-unresolved">Q</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Z</span>.t</span></code></div><div class="spec-doc"><p>Implement the function <code>eval_fractran</code> so that <code>eval_fractran p i</code> evaluates the FRACTRAN program <code>p</code> on the given input <code>i</code>. See the previous assignment for what this means, along with the written problem below. You'll likely want to use the following functions in your implementation.</p><ul><li><code>Q.mul a b</code> is the the result of multiplying <code>a</code> and <code>b</code>.</li><li><code>Q.num a</code> is the numerator of <code>a</code> and is an aribtrary-precision integer (i.e., of type <code>Z.t</code>)</li><li><code>Q.den a</code> is the denominator of <code>a</code> and is an arbitrary-precision integer.</li><li><code>Z.one</code> is the number one as an arbitrary-precision integer.</li></ul><p><i>Important:</i> Arbitrary-precision rationals are always given in reduced form. This makes it easy to determine if a rational can be converted into an integer.</p></div></div><p>The remaining functions are implemented for you.</p><div class="odoc-spec"><div class="spec value anchored" id="val-interp_fractran"><a href="#val-interp_fractran" class="anchor"></a><code><span><span class="keyword">val</span> interp_fractran : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Z</span>.t</span></code></div><div class="spec-doc"><p><code>interp_fractran</code> is <code>parse_fractran</code> followed by <code>eval_fractran</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-max_fractran"><a href="#val-max_fractran" class="anchor"></a><code><span><span class="keyword">val</span> max_fractran : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>max_fractran i j</code> is the same as <code>max i j</code> but implemented in a very round-about way, i.e., by writing the program in FRACTRAN, running our interpreter and extracting the output.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fib_fractran"><a href="#val-fib_fractran" class="anchor"></a><code><span><span class="keyword">val</span> fib_fractran : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>fib_fractran n</code> is the <code>n</code>th value of the Fibonacci sequence, implemented using our FRACTRAN interpreter.</p></div></div><h2 id="written-(60%)"><a href="#written-(60%)" class="anchor"></a>Written (60%)</h2><h3 id="grammar-rule-to-english"><a href="#grammar-rule-to-english" class="anchor"></a>Grammar Rule to English</h3><div><pre class="odoc-katex-math display">   \def\nt#1{\textcolor{blue}{\texttt{&lt;}\texttt{#1}\texttt{&gt;}}}
   \def\tm#1{\textcolor{red}{\texttt{#1}}}
   \nt{expr} \Coloneqq \nt{expr}\tm{.[} \nt{expr} \tm{]}
   </pre></div><p>Write down an English sentence which expresses the same thing as the above grammar rule (this is actual OCaml syntax).</p><h3 id="typing-judgment-to-english"><a href="#typing-judgment-to-english" class="anchor"></a>Typing Judgment to English</h3><div><pre class="odoc-katex-math display">   \def\code#1{\textcolor{purple}{\texttt{#1}}}
   \{ \code{s} : \code{string}, \code{i} : \code{int} \} \vdash
   \code{s.[i]} : \code{char}
   </pre></div><p>Write down an English sentence which expresses the same thing as the above typing judgment.</p><h3 id="typing-rule-to-english"><a href="#typing-rule-to-english" class="anchor"></a>Typing Rule to English</h3><div><pre class="odoc-katex-math display">   \def\code#1{\textcolor{purple}{\texttt{#1}}}
   \frac
   {\Gamma \vdash e_1 : \code{string} \qquad \Gamma \vdash e_2 : \code{int}}
   {\Gamma \vdash e_1\code{.[}e_2\code{]} : \code{char}}
   \ (\text{string-index})
   </pre></div><p>Write down an English sentence which expresses the same thing as the above typing rule.</p><h3 id="typing-judgments-in-ocaml"><a href="#typing-judgments-in-ocaml" class="anchor"></a>Typing Judgments in OCaml</h3><div><pre class="odoc-katex-math display">   \def\code#1{\textcolor{purple}{\texttt{#1}}}
   \Gamma \vdash \code{let rec f x = f (x + g (f y)) in h (g (x = y)) = f x} : \tau
   </pre></div><p>Determine the type <code class="odoc-katex-math">\tau</code> and the <i>smallest</i> context <code class="odoc-katex-math">\Gamma</code> such that the above typing judgment holds in OCaml. (<i>Hint.</i> Come up with dummy values for the unknown variables in the above expression so that you can type it into UTop and it will type-check.)</p><h3 id="fractran_2"><a href="#fractran_2" class="anchor"></a>FRACTRAN</h3><p>(Another problem about FRACTRAN? Probably the last one...) In this problem, we will look at the semantics rules for FRACTRAN.</p><p>The semantic rules for FRACTRAN are given in terms of <i>configurations</i>. A configuation consists of two FRACTRAN programs <code class="odoc-katex-math">P</code> and <code class="odoc-katex-math">Q</code>, and an integer value <code class="odoc-katex-math">n</code>, written <code class="odoc-katex-math">\langle \ P \ , \ Q \ , \ n \ \rangle</code>. We think of <code class="odoc-katex-math">P</code> as the input program, <code class="odoc-katex-math">Q</code> as the part of the program we haven't yet processed, and <code class="odoc-katex-math">n</code> as the input that is updated throughout the evaluation process. An <i>evaluation judgment</i> is of the form</p><div><pre class="odoc-katex-math display">   \langle \ P \ , \ Q \ , \ n \ \rangle
   \longrightarrow
   \langle \ P' \ , \ Q' \ , \ n' \ \rangle
   </pre></div><p>and it means that the configuration the the left-hand-side <i>evaluates to</i> the configuration on the right-hand-side in one step. There are two rules for evaluating a FRACTRAN program.</p><div><pre class="odoc-katex-math display">   \frac
   {\textcolor{green}{\frac{pn}{q} \text{ is an integer}}}
   {\left\langle \ P \ , \ \frac{p}{q} :: Q \ , \ n \ \right\rangle
   \longrightarrow \left\langle \ P \ , \ P \ , \ \frac{pn}{q} \ \right\rangle}
   \ (\text{int})
   \qquad
   \qquad
   \frac
   {\textcolor{green}{\frac{pn}{q} \text{ is not an integer}}}
   {\qquad\qquad???\qquad\qquad}
   \ (\text{not-int})
   </pre></div><p>Recall that the green parts of the rules are called <i>side-conditions</i> because they are not evaluation judgments, they are just conditions that need to hold in order for the rule to be applied. The rule (int) says that if the next fraction <code class="odoc-katex-math">p / q</code> in <code class="odoc-katex-math">Q</code> times our value <code class="odoc-katex-math">n</code> is an integer, then we reset <code class="odoc-katex-math">Q</code> to <code class="odoc-katex-math">P</code> and set <code class="odoc-katex-math">n</code> to <code class="odoc-katex-math">pn / q</code>. The rule (not-int) is missing its conclusion, but should express that if the next fraction <code class="odoc-katex-math">p / q</code> in <code class="odoc-katex-math">Q</code> times <code class="odoc-katex-math">n</code> is <i>not</i> an integer, then we should remove it from <code class="odoc-katex-math">Q</code> and keep <code class="odoc-katex-math">n</code> as it is.</p><p><b>The Task.</b> Write <b>(not-int)</b> as a formal inference rule.</p></div></body></html>
