<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>lab09 (Fall-2025.lab09)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">Fall-2025</a> &#x00BB; lab09</nav><header class="odoc-preamble"><h1 id="lab-8:-formal-grammar-worksheet"><a href="#lab-8:-formal-grammar-worksheet" class="anchor"></a>Lab 8: Formal Grammar Worksheet</h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#ambiguity">Ambiguity</a></li><li><a href="#revisiting-s-expressions">Revisiting S-Expressions</a></li><li><a href="#designing-grammars">Designing Grammars</a></li></ul></nav></div><div class="odoc-content"><h2 id="ambiguity"><a href="#ambiguity" class="anchor"></a>Ambiguity</h2><pre class="language-text"><code>&lt;a&gt; ::= &lt;b&gt; &lt;c&gt;
&lt;b&gt; ::= &lt;b&gt; y | x
&lt;c&gt; ::= &lt;d&gt; | &lt;d&gt; y
&lt;d&gt; ::= z &lt;b&gt; | z</code></pre><ol><li>Give a leftmost derivation of the sentence <code>xyz</code>.</li><li>Draw a parse tree for the sentence <code>xyz</code>.</li><li>Find the <i>shortest</i> sentence accepted by the above grammar which has multiple parse trees. Draw both parse trees.</li></ol><h2 id="revisiting-s-expressions"><a href="#revisiting-s-expressions" class="anchor"></a>Revisiting S-Expressions</h2><p>Use Menhir and OCamllex to build a parser for S-expressions which targets <code>string sexpr</code>. Recall the ADT definition of <code>sexpr</code>:</p><pre class="language-ocaml"><code>type 'a sexpr = Atom of 'a | List of 'a sexpr list</code></pre><p>You should use the following regular expression for atoms in your lexer:</p><pre class="language-ocaml"><code>let atom = [^ ' ' '\t' '\n' '\r' '(' ')']+</code></pre><p>This expression matches any nonempty sequence of non-whitespace non-parentheses characters.</p><h2 id="designing-grammars"><a href="#designing-grammars" class="anchor"></a>Designing Grammars</h2><p>Design an unambiguous grammar for Boolean expressions over the constants <code>True</code> and <code>False</code> in Python. When you're done, compare with the <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations">Python grammar for Boolean operators</a>.</p><p><b>Challenge.</b> We just discussed parser generators in lecture. If you have time, build a parser for these expressions using <code>menhir</code> and <code>ocamllex</code>.</p></div></body></html>
