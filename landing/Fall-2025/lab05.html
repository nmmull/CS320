<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>lab05 (Fall-2025.lab05)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../odoc.support/katex.min.css"/><script src="../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">Fall-2025</a> &#x00BB; lab05</nav><header class="odoc-preamble"><h1 id="lab-5:-mutual-recursion-and-options"><a href="#lab-5:-mutual-recursion-and-options" class="anchor"></a>Lab 5: Mutual Recursion and Options</h1><p>In this lab, we'll practice mutual recursion and working with options. I recommend pair programming for the OCaml problem; since there's nothing to turn in, it would be a good way to talk through how to approach it.</p><p>As usual, use <code>dune init project lab05</code> to create a dune project for this lab.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#ocaml-problem:-mutual-recursion">OCaml Problem: Mutual Recursion</a></li><li><a href="#derivation-problem:-options">Derivation Problem: Options</a></li></ul></nav></div><div class="odoc-content"><h2 id="ocaml-problem:-mutual-recursion"><a href="#ocaml-problem:-mutual-recursion" class="anchor"></a>OCaml Problem: Mutual Recursion</h2><p>Consider the following ADT, which represents trees with nodes that either have 2 or 3 children.</p><pre class="language-ocaml"><code>type 'a tree23 =
  | Leaf
  | Node2 of 'a * 'a tree23 * tree23
  | Node3 of 'a * 'a tree23 * tree23 * tree23</code></pre><p>Suppose we wanted to further restrict the ADT so that nodes which are an even distance from the root have 2 children and nodes which are an odd distance from the root have 3 children (it's possible in the current version of the ADT to have nodes with 2 or 3 children anywhere in the tree). We can't do this with a single ADT, but we <i>can</i> do it with multiple mutually recursive ADTs:</p><pre class="language-ocaml"><code>type 'a tree23 =
  | Leaf2
  | Node2 of 'a * 'a tree32 * 'a tree32
and 'a tree32 =
  | Leaf3
  | Node3 of 'a * 'a tree23 * 'a tree23 * 'a tree23</code></pre><p>Here we require the childen of a <code>Node2</code> to be <code>tree23</code>s and the children of <code>Node3</code> to be <code>tree32</code>s. Note the keyword <code>and</code>, which we use to let OCaml know that we're making something mututally recursive. A simple example:</p><pre class="language-ocaml"><code>let example : int tree23 =
  Node2
    ( 1
    , Node3
        ( 2
        , Node2 (3, Leaf3, Leaf3)
        , Node2 (4, Leaf3, Leaf3)
        , Node2 (5, Leaf3, Leaf3)
        )
    , Node3
        ( 6
        , Node2 (7, Leaf3, Leaf3)
        , Leaf2
        , Leaf2
        )
    )</code></pre><p>Implement the functions <code>count</code> and <code>sum</code> for <code>tree23</code>, where <code>count t</code> is the number of nodes in <code>t</code> and <code>sum t</code> is the sum of the (integer) values in <code>t</code>. You'll need write these functions <i>mutually recursively</i>, e.g., in order to count nodes in <code>tree23</code>s, you need to count nodes in <code>tree32</code>s, and vice versa. <b>Hint:</b> You can use the keyword <code>and</code> for mutually recursive functions as well.</p><pre class="language-ocaml"><code>let _ = assert (Lab05.count example = 7)
let _ = assert (Lab05.sum example = 28)</code></pre><h2 id="derivation-problem:-options"><a href="#derivation-problem:-options" class="anchor"></a>Derivation Problem: Options</h2><p>At this point, we've seen quite a few inference rules, even some more complex ones like the one for list matching. Here we want you to start thinking about how to write these yourself. We just learned about options, we'll go over the rules in lecture, but in in this lab let's try this out ourselves. We'll give you the syntax:</p><pre class="language-ocaml"><code>&lt;expr&gt; ::= None
&lt;expr&gt; ::= Some &lt;expr&gt;
&lt;expr&gt; ::= match &lt;expr&gt; with | None -&gt; &lt;expr&gt; | Some &lt;var&gt; -&gt; &lt;expr&gt;</code></pre><p>In other words:</p><ul><li><code>None</code> is a well-formed expression.</li><li>If <code class="odoc-katex-math">e_1</code> is a well-formed expression then so is <code>Some</code> <code class="odoc-katex-math">e_1</code>.</li><li>If <code class="odoc-katex-math">e_1</code>, <code class="odoc-katex-math">e_2</code>, and <code class="odoc-katex-math">e_3</code> are well-formed expressions, and <code class="odoc-katex-math">x</code> is a variable, then <code>match</code> <code class="odoc-katex-math">e_1</code> <code>with | None -&gt;</code> <code class="odoc-katex-math">e_2</code> <code>| Some</code> <code class="odoc-katex-math">x</code> <code>-&gt;</code> <code class="odoc-katex-math">e_2</code> is a well-formed expression.</li></ul><p>We'll also introduce new values:</p><ul><li><code class="odoc-katex-math">\mathsf{None}</code> is a value.</li><li><code class="odoc-katex-math">\mathsf{Some}(v)</code> is a value for any value <code class="odoc-katex-math">v</code>.</li></ul><p><b>The tasks:</b></p><ul><li>Write the typing rules for options.</li><li>Write the semantic rules for options.</li><li><p>Write a derivation of the following typing judgment:</p><div><pre class="odoc-katex-math display">\varnothing \vdash \texttt{fun x -&gt; match x with | None -&gt; 0 | Some y -&gt; y} : \texttt{option int -&gt; int}</pre></div><p>You'll also need the rules <b>(var)</b>, <b>(fun)</b> and <b>(int)</b>. Take a look at previous labs to remind yourself of these rules.</p></li><li><p>Write a derivation of the following semantic judgment:</p><div><pre class="odoc-katex-math display">\texttt{match Some 2 with | None -&gt; 0 | Some y -&gt; y} \Downarrow 2</pre></div><p>You'll also need the rules <b>(int-eval)</b>. Take a look at the previous labs to remind yourself of these rules.</p></li></ul></div></body></html>
