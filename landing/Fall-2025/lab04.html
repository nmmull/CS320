<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>lab04 (Fall-2025.lab04)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../odoc.support/katex.min.css"/><script src="../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">Fall-2025</a> &#x00BB; lab04</nav><header class="odoc-preamble"><h1 id="lab-4:-adts-and-derivations"><a href="#lab-4:-adts-and-derivations" class="anchor"></a>Lab 4: ADTs and Derivations</h1><p>In this lab, we'll practice working with algebraic data types. I recommend pair programming; since there's nothing to turn in, it would be a good way to talk through how to approach each problem.</p><p>As usual, use <code>dune init project lab04</code> to create a dune project for this lab.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#ocaml-problem">OCaml Problem</a></li><li><a href="#derivation-problem">Derivation Problem</a></li></ul></nav></div><div class="odoc-content"><h2 id="ocaml-problem"><a href="#ocaml-problem" class="anchor"></a>OCaml Problem</h2><p>Consider the following two algebraic data types.</p><pre class="language-ocaml"><code>type int_or_string
  = Int of int
  | String of string

type int_list_or_string_list
  = IntList of int list
  | StringList of string list</code></pre><p>The first represents either an <code>int</code> or a <code>string</code>, and the second represents either an <code>int list</code> or a <code>string list</code>. Implement the function <code>convert</code> so that <code>convert l</code> is an <code>int_list_or_string_list list</code> in which adjacent <code>string</code> values and <code>int</code> values in <code>l</code> are grouped together.</p><pre class="language-ocaml"><code>let l_in = [Int 2; Int 3; String &quot;a&quot;; String &quot;b&quot;; Int 4; String &quot;c&quot;]
let l_out = [IntList [2;3]; StringList [&quot;a&quot;;&quot;b&quot;]; IntList [4]; StringList [&quot;c&quot;]]
let _ = assert (convert l_in = l_out);</code></pre><p>*)</p><h2 id="derivation-problem"><a href="#derivation-problem" class="anchor"></a>Derivation Problem</h2><p>Suppose you're interested in adding a kind of functional for-loop into an OCaml-like language. You decide on the syntax</p><pre class="language-ocaml"><code>&lt;expr&gt; ::= repeat &lt;expr&gt; times &lt;expr&gt; from &lt;expr&gt;</code></pre><p>That is, if <code class="odoc-katex-math">e_1</code>, <code class="odoc-katex-math">e_2</code>, and <code class="odoc-katex-math">e_3</code> are well-formed expressions, then so is</p><div><pre class="odoc-katex-math display">\texttt{repeat} \ e_1 \ \texttt{times} \ e_2 \ \texttt{from} \ e_3
</pre></div><p>The hope is that you can write code like</p><pre class="language-ocaml"><code>let fact n =
  let loop =
    repeat n times
      let (i, m) = acc in
      (i + 1, m * i)
    from
      (1, 1)
  in let (_, out) = loop in out</code></pre><p>or even:</p><pre class="language-ocaml"><code>let fact n =
  let loop =
    repeat n times
      { i = acc.i + 1; out = acc.out * acc.i }
    from
      { i = 1; out = 1 }
  in loop.out</code></pre><p>We require in <code>repeat n times e1 from e2</code> that <code>n</code> is an <code>int</code> and the <code>e1</code> and <code>e2</code> have the same type. Furthermore we require that <code>e1</code> is well-typed a context which <b>includes a variable <code>acc</code> which is the same type as that of <code>e1</code> and <code>e2</code></b>. Finally, the resulting type should be that of <code>e1</code> and <code>e2</code>.</p><p><b>The Task.</b> Write this typing rule <b>(repeat)</b> for this new language construct. Then determine a context <code class="odoc-katex-math">\Gamma</code> and a type <code class="odoc-katex-math">\tau</code> such that the following is derivable, and give a derivation.</p><div><pre class="odoc-katex-math display">\def\code#1{\textcolor{purple}{\texttt{#1}}}
\Gamma \vdash \code{repeat n times match acc with | (i, m) -&gt; (i + 1, m * i) from (1, 1)} : \tau
</pre></div><p>You should use the following rules in addition to the <b>(repeat)</b> rule.</p><div><pre class="odoc-katex-math display">\def\code#1{\textcolor{purple}{\texttt{#1}}}
\def\side#1{\textcolor{green}{#1}}
\frac
{\side{\code{n} \text{ is an \code{int} literal}}}
{\Gamma \vdash \code{n} : \code{int}}
\text{(int)}
\qquad
\frac{\side{(x : \tau) \in \Gamma}}{\Gamma \vdash x : \tau} \text{(var)}
\qquad
\frac{\Gamma \vdash e_1 : \code{int} \qquad \Gamma \vdash e_2 : \code{int}}{\Gamma \vdash e_1 \code{ + } e_2 : \code{int}} \text{(add)
}
\qquad
\frac{\Gamma \vdash e_1 : \code{int} \qquad \Gamma \vdash e_2 : \code{int}}{\Gamma \vdash e_1 \code{ * } e_2 : \code{int}} \text{(mul)
}
</pre></div><div><pre class="odoc-katex-math display">\def\code#1{\textcolor{purple}{\texttt{#1}}}
\def\side#1{\textcolor{green}{#1}}
\frac{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2}
{\Gamma \vdash \code{( } e_1 \code{ , } e_2 \code{ )} : \tau_1 \code{ * } \tau_2}
\text{(tuple)}
\qquad
\frac{\Gamma \vdash e_1 : \tau_1 \code{ * } \tau_2 \quad \Gamma, x : \tau_1, y : \tau_2 \vdash e_2 : \tau}
{\Gamma \vdash \code{match } e_1 \code{ with | ( } x \code{ , } y \code{ ) -&gt; } e_2 : \tau}
\text{(tupleMatch)}
</pre></div><p><b>Challenge.</b> Write the semantic rules for this new language construct.</p></div></body></html>
