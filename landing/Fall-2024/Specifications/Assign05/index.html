<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign05 (Fall-2024.Specifications.Assign05)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Fall-2024</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign05</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign05</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#assignment-5">Assignment 5</a><ul><li><a href="#programming-part">Programming Part</a><ul><li><a href="#problem-1:-folding-and-ounit2">Problem 1: Folding and OUnit2</a></li><li><a href="#problem-2:-continuation-passing-style-(extra-credit)">Problem 2: Continuation Passing Style <b>(Extra Credit)</b></a></li><li><a href="#problem-3:-anonymous-functions">Problem 3: Anonymous Functions</a></li><li><a href="#problem-4:-sets">Problem 4: Sets</a></li></ul></li><li><a href="#written-part">Written Part</a><ul><li><a href="#problem-1:-recursive-functions">Problem 1: Recursive Functions</a></li><li><a href="#problem-2:-anonymous-functions">Problem 2: Anonymous Functions</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="assignment-5"><a href="#assignment-5" class="anchor"></a>Assignment 5</h2><p>This assignment is due on <b>Thursday 10/10 by 11:59PM</b>. It includes both a programming part and a written part which are to be submitted on Gradescope under <i>assign05</i> and <i>assign05 (written)</i>, respectively.</p><p>In order to run the given test suite you have to define every required function in the assignment. <b>We would recommend creating dummy values for each problem when you start</b> if you want to be able to run tests as you work.</p><h3 id="programming-part"><a href="#programming-part" class="anchor"></a>Programming Part</h3><h4 id="problem-1:-folding-and-ounit2"><a href="#problem-1:-folding-and-ounit2" class="anchor"></a>Problem 1: Folding and OUnit2</h4><p>Roughly speaking, test suites in OUnit2 are represented by the following ADT.</p><div class="odoc-spec"><div class="spec type anchored" id="type-test"><a href="#type-test" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a test</span></span><span> = </span></code><ol><li id="type-test.TestCase" class="def variant constructor anchored"><a href="#type-test.TestCase" class="anchor"></a><code><span>| </span><span><span class="constructor">TestCase</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></li><li id="type-test.TestList" class="def variant constructor anchored"><a href="#type-test.TestList" class="anchor"></a><code><span>| </span><span><span class="constructor">TestList</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="#type-test">test</a></span> list</span></span></code></li></ol></div></div><p>A test suite is either a test case (created using the <code>(&gt;::)</code> operator) or made up of a list of other test suites (created using the <code>(&gt;:::)</code> operator). The ADT is parametrized by the type variable <code>'a</code> because there are multiple kinds of test cases.</p><p>When we check a test suite, we run each test in that suite from left to right (i.e., in-order traversal) and collect all the results. This is most naturally represented by a <i>fold</i> operation over the test suite.</p><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-test">test</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Implement the function <code>fold_left</code> so that <code>fold_left op base test</code> is the result of applying <code>op</code> left-associatively to the test cases in <code>test</code> from left to right, starting with <code>base</code>.</p><p>Put your solution in a file called <code>assign05/lib/assign05_01.ml</code>. See the file <code>assign05/test/test_suite/test01.ml</code> for example output behavior. In particular, it may be useful to look at the function <code>all_results</code> (which is not unlike how we calculate grades from an OUnit2 test suite). <b>IMPORTANT:</b> You must include the definition of the type <code>test</code> in your solution.</p></div></div><h4 id="problem-2:-continuation-passing-style-(extra-credit)"><a href="#problem-2:-continuation-passing-style-(extra-credit)" class="anchor"></a>Problem 2: Continuation Passing Style <b>(Extra Credit)</b></h4><p>We won't have an opportunity to discuss more deeply the notion of continuation passing style in this course, but we'll get a taste of it in this problem.</p><p>When we introduced tail recursion, we said that <i>any</i> function can be made tail recursive. This might be difficult to imagine when it comes to trees.</p><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a tree</span></span><span> = </span></code><ol><li id="type-tree.Leaf" class="def variant constructor anchored"><a href="#type-tree.Leaf" class="anchor"></a><code><span>| </span><span><span class="constructor">Leaf</span></span></code></li><li id="type-tree.Node" class="def variant constructor anchored"><a href="#type-tree.Node" class="anchor"></a><code><span>| </span><span><span class="constructor">Node</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-tree">tree</a></span> * <span><span class="type-var">'a</span> <a href="#type-tree">tree</a></span></span></code></li></ol></div></div><p>Take for example the function which sums the elements of a tree.</p><pre class="language-ocaml"><code>let rec sum t =
  match t with
  | Leaf -&gt; 0
  | Node (x, l, r) -&gt; x + sum l + sum r</code></pre><p>A first attempt at a tail recursive version of this function might look like:</p><pre class="language-ocaml"><code>let sum_tr =
  let rec go acc t =
    match t with
    | Leaf -&gt; acc
    | Node (x, l, r) -&gt; go (acc + x) ???
  in go 0</code></pre><p>But it's unclear what we should recurse on, the left child, the right child, some combination? And does it really make sense to return the accumulated value at any leaf?</p><p><b>Continuation passing style</b> (CPS) is a general technique for making any function tail recursive. The rough idea is to take as an argument a <i>continuation</i> which is a <i>function</i> that's called to &quot;continue&quot; the computation after we've computed our desired value.</p><p>This gives recursive functions access to what will happen <i>after</i> their done being evaluated. We can leverage this by pushing some of the computation into <i>the continuation itself</i>. Since the body of a function isn't evaluated until the function is called, we can essentially &quot;hide&quot; recursive calls in the continuation.</p><p>Let's consider an example. Here's the standard tail recursive sum function for lists as well as the CPS version.</p><pre class="language-ocaml"><code>let list_sum_tr =
  let rec go acc l =
    match l with
    | [] -&gt; acc
    | x :: xs -&gt; go (x + acc) xs
  in go 0

let list_sum_tr_cont l =
  let rec go l cont =
    match l with
    | [] -&gt; cont 0
    | x :: xs -&gt; go xs (fun sum_xs -&gt; cont (x + sum_xs))
  in go l (fun x -&gt; x)</code></pre><p>Let's break this down. The function <code>go</code> takes as arguments <code>l</code> of type <code>int list</code> and <code>cont</code> of type <code>int -&gt; 'a</code>. The argument <code>cont</code> is the continuation. It's the function we call <i>on the sum of the elements of <code>l</code></i> once we've figured that out. So:</p><ul><li>If <code>l</code> is empty, then the sum is <code>0</code> and we continue by calling <code>cont</code> on <code>0</code>.</li><li>If <code>l</code> is nonempty of the form <code>x :: xs</code>, then we figure out the sum of the elements of <code>xs</code>, and continue by calling the continuation on the sum of the elements of <code>xs</code> <i>plus <code>x</code></i>. That way, we're ultimately calling the continuation on the sum of the elements of <code>l</code>.</li></ul><p>Finally, we call <code>go</code> on the identity continuation <code>fun x -&gt; x</code> so that what we do after we get the sum of the elements in <code>l</code> is just return the sum.</p><p>In a bit more detail, the evaluation goes as follows:</p><pre class="language-ocaml"><code>go [1;2] (fun x -&gt; x)                                                        ----&gt;
go [2] (fun sum_2 -&gt; (fun x -&gt; x) (1 + sum_2))                               ----&gt;
go [] (fun sum_nil -&gt; (fun sum2 -&gt; (fun x -&gt; x) (1 + sum_2)) (2 + sum_nil))  ----&gt;
(fun sum_nil -&gt; (fun sum2 -&gt; (fun x -&gt; x) (1 + sum_12)) (2 + sum_nil)) 0     ----&gt;
(fun sum2 -&gt; (fun x -&gt; x) (1 + sum_2)) (2 + 0)                               ----&gt;
(fun x -&gt; x) (1 + (2 + 0))                                                   ----&gt;
1 + (2 + 0)</code></pre><p>In essence, we're encoding the sum in a sequence of function calls.</p><div class="odoc-spec"><div class="spec value anchored" id="val-sum_tr"><a href="#val-sum_tr" class="anchor"></a><code><span><span class="keyword">val</span> sum_tr : <span><span>int <a href="#type-tree">tree</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Implement the function <code>sum_tr</code> so that <code>sum_tr t</code> is the sum of the elements in <code>t</code>. Your implementation <b>must</b> be tail recursive. You should use the above example as a prototype for continuation passing style. A rough outline of the function:</p><ul><li>If the tree is empty, call your continuation on <code>0</code>.</li><li>If the tree is nonempty, then recurse on the left child, and then <i>in the continuation</i> recurse on the right child.</li></ul><p>Put your solution in a file called <code>assign05/lib/assign05_02.ml</code>. See the file <code>assign05/test/test_suite/test02.ml</code> for example output behavior. <b>IMPORTANT:</b> You must include the definition of the type <code>tree</code> in your code. <b>IMPORTANT:</b> Even if you don't want to attempt this problem, you should fill in a dummy value, something like</p><pre class="language-ocaml"><code>type 'a tree =
  | Leaf
  | Node of 'a * 'a tree * 'a tree

fun sum_tr _ = 12345</code></pre></div></div><h4 id="problem-3:-anonymous-functions"><a href="#problem-3:-anonymous-functions" class="anchor"></a>Problem 3: Anonymous Functions</h4><p>Consider the following ADT for expressions in a language with typed anonymous functions (this is sometimes called the <i>simply typed lambda calculus</i>).</p><div class="odoc-spec"><div class="spec type anchored" id="type-ident"><a href="#type-ident" class="anchor"></a><code><span><span class="keyword">type</span> ident</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span><span class="keyword">type</span> ty</span><span> = </span></code><ol><li id="type-ty.Unit" class="def variant constructor anchored"><a href="#type-ty.Unit" class="anchor"></a><code><span>| </span><span><span class="constructor">Unit</span></span></code></li><li id="type-ty.Arr" class="def variant constructor anchored"><a href="#type-ty.Arr" class="anchor"></a><code><span>| </span><span><span class="constructor">Arr</span> <span class="keyword">of</span> <a href="#type-ty">ty</a> * <a href="#type-ty">ty</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.Var" class="def variant constructor anchored"><a href="#type-expr.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> <a href="#type-ident">ident</a></span></code></li><li id="type-expr.Fun" class="def variant constructor anchored"><a href="#type-expr.Fun" class="anchor"></a><code><span>| </span><span><span class="constructor">Fun</span> <span class="keyword">of</span> <a href="#type-ident">ident</a> * <a href="#type-ty">ty</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.App" class="def variant constructor anchored"><a href="#type-expr.App" class="anchor"></a><code><span>| </span><span><span class="constructor">App</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li></ol></div></div><p>For example, the expression</p><pre class="language-ocaml"><code>(fun (f : unit -&gt; unit) -&gt; fun (x : unit) -&gt; f x) (fun (y : unit) -&gt; y)</code></pre><p>can be represented by the value</p><pre class="language-ocaml"><code>App
( Fun
  ( &quot;f&quot;
  , Arr (Unit, Unit)
  , Fun
    ( &quot;x&quot;
    , Unit
    , App (Var &quot;f&quot;, Var &quot;x&quot;)
    )
  )
, Fun (&quot;y&quot;, Unit, Var &quot;y&quot;)
)</code></pre><p>We type expressions according to the following rules.</p><div><pre class="odoc-katex-math display">    \frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}
    \qquad
    \frac
    {\Gamma, x : \tau_1 \vdash e : \tau_2}
    {\Gamma \vdash \texttt{fun} \ \texttt{(} x \ \texttt{:} \ \tau_1 \texttt{)} \ \texttt{-&gt;} \ e : \tau_1 \to \tau_2}
    \qquad
    \frac
    {\Gamma \vdash e_1 : \tau_2 \to \tau
     \qquad
     \Gamma \vdash e_2 : \tau_2
    }
    {\Gamma \vdash e_1 \ e_2 : \tau}
    </pre></div><div class="odoc-spec"><div class="spec type anchored" id="type-ctxt"><a href="#type-ctxt" class="anchor"></a><code><span><span class="keyword">type</span> ctxt</span><span> = <span><span>(<a href="#type-ident">ident</a> * <a href="#type-ty">ty</a>)</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_of"><a href="#val-type_of" class="anchor"></a><code><span><span class="keyword">val</span> type_of : <span><a href="#type-ctxt">ctxt</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ty">ty</a> option</span></span></code></div><div class="spec-doc"><p>Implement the function <code>type_of</code> so that <code>type_of gamma e</code> is <code>Some t</code> if <code>e</code> has type <code>t</code> in the context <code>gamma</code>, and is <code>None</code> otherwise.</p><p>Put your solution in a file called <code>assign05/lib/assign05_03.ml</code>. See the file <code>assign05/test/test_suite/test03.ml</code> for example output behavior. <b>IMPORTANT:</b> You must include the definitions of <code>type</code> and <code>expr</code> in your code.</p></div></div><h4 id="problem-4:-sets"><a href="#problem-4:-sets" class="anchor"></a>Problem 4: Sets</h4><p>Consider the following signature for a finite integer sets (click <code>INT_SET</code> to expand).</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-INT_SET"><a href="#module-type-INT_SET" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-INT_SET/index.html">INT_SET</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-set_info"><a href="#type-set_info" class="anchor"></a><code><span><span class="keyword">type</span> set_info</span><span> = </span><span>{</span></code><ol><li id="type-set_info.ind" class="def record field anchored"><a href="#type-set_info.ind" class="anchor"></a><code><span>ind : <span>int <span class="arrow">&#45;&gt;</span></span> bool;</span></code></li><li id="type-set_info.mn" class="def record field anchored"><a href="#type-set_info.mn" class="anchor"></a><code><span>mn : int;</span></code></li><li id="type-set_info.mx" class="def record field anchored"><a href="#type-set_info.mx" class="anchor"></a><code><span>mx : int;</span></code></li></ol><code><span>}</span></code></div></div><p>In this problem, you need to implement two modules with the above signature.</p><ul><li><code>ListSet</code>, which takes <code>t</code> to be <code>int list</code>, and represents finite sets of integer as <b>sorted</b> lists of <b>distinct</b> integers (i.e., no repeats).</li><li><code>FuncSet</code>, which takes <code>t</code> to be the record type <code>set_info</code> defined above. <code>ind</code> is an indicator for which elements appear in the set, and <code>mn</code> and <code>mx</code> are lower and upper bounds, respectively, for the elements in the set. You <b>must</b> maintain the invariant that if the set is not empty, then <code>mn</code> and <code>mx</code> are elements of the set. If the set is empty, then <code>mn</code> and <code>mx</code> may be any values such that <code>mn &gt; mx</code>.</li></ul><p>Put your solution in a file called <code>assign05/lib/assign05_04.ml</code>. See the file <code>assign05/test/test_suite/test04.ml</code> for example output behavior.</p><p><b>IMPORTANT:</b> You must include the definition of <code>set_info</code> in your code. You should <b>not</b> include the module signature <code>INT_SET</code> and you should <b>not</b> or give a signature to the modules <code>ListSet</code> or <code>FuncSet</code>. That is, you should write</p><pre class="language-ocaml"><code>module ListSet = struct
 (* ... *)
end</code></pre><p>and you should <b>not</b> write</p><pre class="language-ocaml"><code>module ListSet : INT_SET = struct
  (* ... *)
end</code></pre><p>The signatures of <code>ListSet</code> and <code>FuncSet</code> are already given in the <code>.mli</code> file. Finally, you should leave the files <code>assign05_04.mli</code> and <code>assign05_04_intf.ml</code> as they are.</p><h3 id="written-part"><a href="#written-part" class="anchor"></a>Written Part</h3><h4 id="problem-1:-recursive-functions"><a href="#problem-1:-recursive-functions" class="anchor"></a>Problem 1: Recursive Functions</h4><p>So far, we haven't introduced any rules for typing recursive functions. Here's such a rule.</p><div><pre class="odoc-katex-math display">    \frac
    {\Gamma, f : \tau \to \tau_1, x : \tau \vdash e_1 : \tau_1
     \qquad
     \Gamma, f : \tau \to \tau_1 \vdash e_2 : \tau_2
    }
    {\Gamma \vdash \texttt{let rec} \ f \ x \ \texttt{=} \ e_1 \ \texttt{in} \ e_2 : \tau_2}
    </pre></div><p>The difference between this and our <code class="odoc-katex-math">\textsf{LetFunc}</code> rule is that the variable <code class="odoc-katex-math">f</code> appears in the context of the left premise. Using this rule, give a typing derivation to the following judgment.</p><div><pre class="odoc-katex-math display">    \cdot \vdash \texttt{let rec f n = if n = 0 then 1 else f (n - 1) in f 10} : \texttt{int}
    </pre></div><h4 id="problem-2:-anonymous-functions"><a href="#problem-2:-anonymous-functions" class="anchor"></a>Problem 2: Anonymous Functions</h4><p>We also haven't given a rule for evaluating anonymous function applications. Here's such a rule.</p><div><pre class="odoc-katex-math display">    \frac{e_2 \Downarrow v_2 \qquad [v_2 / x] e_1 \Downarrow v}
    {(\texttt{fun} \ x \ \texttt{-&gt;} \ e_1) \ e_2 \Downarrow v}
    </pre></div><p>Using this rule, give a derivation for the following judgment</p><div><pre class="odoc-katex-math display">    \texttt{(fun x -&gt; x + 1) ((fun x -&gt; x * x) 3)} \Downarrow \texttt{10}
    </pre></div><p><i>Remark:</i> We're being a little informal here, things get a bit more complicated when we start evaluating higher-order functions.</p></div></body></html>
