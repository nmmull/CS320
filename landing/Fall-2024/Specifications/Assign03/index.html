<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign03 (Fall-2024.Specifications.Assign03)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Fall-2024</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign03</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign03</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#assignment-3">Assignment 3</a><ul><li><a href="#programming-part">Programming Part</a><ul><li><a href="#problem-1:-unique-keys">Problem 1: Unique Keys</a></li><li><a href="#problem-2:-generalized-fibonacci-(tail-recursion)">Problem 2: Generalized Fibonacci (Tail-Recursion)</a></li><li><a href="#problem-3:-tree-collapsing">Problem 3: Tree Collapsing</a></li><li><a href="#problem-4:-grouping">Problem 4: Grouping</a></li></ul></li><li><a href="#written-part">Written Part</a><ul><li><a href="#problem-1:-typing-derivations">Problem 1: Typing Derivations</a></li><li><a href="#problem-2:-semantic-derivations">Problem 2: Semantic Derivations</a></li></ul></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="assignment-3"><a href="#assignment-3" class="anchor"></a>Assignment 3</h2><p>This assignment is due on <b>Thursday 9/26 by 11:59PM</b>. It include both a programming part and a written part which are to be submitted on Gradescope under <i>assign03</i> and <i>assign03 (written)</i>, respectively.</p><p><b>A Note on Testing:</b> You'll notice this time around that the tests for this assignment are divided per problem. If you want to run just the tests for problem 2, for example, you can run</p><pre class="language-ocaml"><code>dune exec -- ./test/test_assign03_02.exe</code></pre><p>Note the <code>.exe</code> extension. Running <code>dune test</code> will run all tests. In order to run the tests you still have to have defined every function in the assignment. <b>We would recommend creating dummy values for each problem when you start</b> if you want to be able to run tests as you work.</p><h3 id="programming-part"><a href="#programming-part" class="anchor"></a>Programming Part</h3><h4 id="problem-1:-unique-keys"><a href="#problem-1:-unique-keys" class="anchor"></a>Problem 1: Unique Keys</h4><p>An association list in OCaml is not required to have unique keys. The function <code>List.assoc</code> looks up elements from left to right, so that if there are keys mapped to multiple values, only the most recently added value is returned.</p><p>However, it can be useful to assume that an association list has unique keys.</p><div class="odoc-spec"><div class="spec value anchored" id="val-mk_unique_keys"><a href="#val-mk_unique_keys" class="anchor"></a><code><span><span class="keyword">val</span> mk_unique_keys : <span><span><span>(string * int)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(string * int)</span> list</span></span></code></div><div class="spec-doc"><p>Implement the function <code>mk_unique_keys</code> which given an association list <code>alst</code> with potentially repeating keys, returns a new association list with unique keys, and the property that <i>the value associated with a key is the <b>sum</b> of all the values it is mapped to in <code>alst</code></i>. There is no requirement on the order of key-value pairs in the resultant association list.</p><pre class="language-ocaml"><code>let alst = [(&quot;the&quot;, 1); (&quot;cat&quot;, 1); (&quot;in&quot;, 1); (&quot;the&quot;, 1); (&quot;hat&quot;, 1)]
let alst = mk_unique_keys alst
let _ = assert (List.assoc &quot;cat&quot; alst = 1)
let _ = assert (List.assoc &quot;the&quot; alst = 2)</code></pre><p>Put your solution in a file called <code>assign03/lib/assign03_01.ml</code>. See the file <code>assign03/test/test_suite/test01.ml</code> for more example output behavior.</p></div></div><h4 id="problem-2:-generalized-fibonacci-(tail-recursion)"><a href="#problem-2:-generalized-fibonacci-(tail-recursion)" class="anchor"></a>Problem 2: Generalized Fibonacci (Tail-Recursion)</h4><p>The Fibonacci sequence is defined as:</p><div><pre class="odoc-katex-math display">    F_n =
    \begin{cases}
    1 &amp; n &lt; 2 \\
    F_{n - 1} + F_{n - 2} &amp; n \geq 2
    \end{cases}
    </pre></div><p>This sequence can be generalized as follows. Given a list of starting values <code class="odoc-katex-math">l</code>, we define the sequence</p><div><pre class="odoc-katex-math display">    G^l_n =
    \begin{cases}
    l[i] &amp; i &lt; \mathsf{len}(l) \\
    \sum_{i = 1}^{\mathsf{len}(l)} G^l_{n - i} &amp; i \geq \mathsf{len}(l)
    \end{cases}
    </pre></div><p>This is exactly the Fibonacci sequence when <code class="odoc-katex-math">l</code> is <code>[1; 1]</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-gen_fib"><a href="#val-gen_fib" class="anchor"></a><code><span><span class="keyword">val</span> gen_fib : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Implement the function <code>gen_fib</code> which, given a list of starting values <code>l</code> and an index <code>k</code>, returns <code class="odoc-katex-math">G^l_k</code> as defined above. Furthermore, <b>your solution must be tail recursive</b>. Note that the operator <code>@</code> is technically not tail recursive, but you are allowed to use it in your solution. (For an added challenge, try to make the running time of your implementation independent of <code class="odoc-katex-math">\mathsf{len}(l)</code> asymptotically.) The behavior of the implementation is undefined if the starting list <code>l</code> is empty or the index <code>k</code> is negative.</p><p>Put your solution in a file called <code>assign03/lib/assign03_02.ml</code>. See the file <code>assign03/test/test_suite/test03.ml</code> for more example output behavior.</p></div></div><h4 id="problem-3:-tree-collapsing"><a href="#problem-3:-tree-collapsing" class="anchor"></a>Problem 3: Tree Collapsing</h4><p>One way to represent trees in OCaml is with the following recursive ADT. In this representation, a node may have zero or more children (as opposed to exactly two in the case of binary trees).</p><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> tree</span><span> = </span></code><ol><li id="type-tree.Leaf" class="def variant constructor anchored"><a href="#type-tree.Leaf" class="anchor"></a><code><span>| </span><span><span class="constructor">Leaf</span> <span class="keyword">of</span> int</span></code></li><li id="type-tree.Node" class="def variant constructor anchored"><a href="#type-tree.Node" class="anchor"></a><code><span>| </span><span><span class="constructor">Node</span> <span class="keyword">of</span> <span><a href="#type-tree">tree</a> list</span></span></code></li></ol></div></div><p>The height of a tree is defined as the maximum number of steps from the root to a leaf or node. If a tree is just a leaf or a node with no children, then it has height <code class="odoc-katex-math">0</code> (this may be different from other definitions of height). So, for example, the tree</p><pre class="language-ocaml"><code>let t =
  Node
    [ Node
      [ Leaf 1
      ; Node []
      ; Leaf 100
      ]
    ; Leaf 1
    ]</code></pre><p>has height 2 (<i>Hint.</i> See the file <code>test/test_suite/test03.ml</code> for an implement of the <code>height</code> function).</p><p>The height of an element in a tree (i.e., a node or a leaf in a tree) is the number of steps from the root to that element. Note that the height of an element is at most the height of the tree.</p><p>An element in a tree is <i>terminal</i> if it a leaf or a node with no children. Note that terminal elements are the only elements whose height can be the same as the height of the tree.</p><p>The process of <i>collapsing</i> a tree to height <code class="odoc-katex-math">i</code> (where <code class="odoc-katex-math">i &gt; 0</code>) is defined formally as follows: for every node <code class="odoc-katex-math">N</code> of height <code class="odoc-katex-math">i - 1</code>, replace its children with the terminal elements in the subtree rooted at <code class="odoc-katex-math">N</code>, in order from left to right. So for example, collapsing <code>t</code> above to height <code class="odoc-katex-math">1</code> would yield the tree</p><pre class="language-ocaml"><code>let t =
  Node
    [ Leaf 1
    ; Node []
    ; Leaf 100
    ; Leaf 1
    ]</code></pre><div class="odoc-spec"><div class="spec value anchored" id="val-collapse"><a href="#val-collapse" class="anchor"></a><code><span><span class="keyword">val</span> collapse : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-tree">tree</a></span></code></div><div class="spec-doc"><p>Implement a function <code>collapse</code> which, given a <i>positive</i> integer <code>h</code>, and a tree <code>t</code>, returns the same tree collapsed to height <code>h</code>. The behavior of the implementation is undefined if <code>h</code> is not positive.</p><p>Put your solution in a file called <code>assign03/lib/assign03_03.ml</code>. See the file <code>assign03/test/test_suite/test03.ml</code> for example output behavior. <b>Important.</b> You <i>must</i> include the definition of <code>tree</code> in your solution.</p></div></div><h4 id="problem-4:-grouping"><a href="#problem-4:-grouping" class="anchor"></a>Problem 4: Grouping</h4><p>A list of integers <code>l</code> is <i>valid</i> if it satisfies the following properties:</p><ul><li>every <code>0</code> appearing in <code>l</code> <b>must</b> have nonzero integers to the left and right of it <b>of opposite signs</b></li><li>for every nonzero entry <code>x</code> of <code>l</code>, if there is an entry adjacent to <code>x</code>, then it must be the same sign as <code>x</code> or <code>0</code></li></ul><p>Lists which do not not satisfy these properties are <i>invalid</i>. So, for example</p><pre class="language-ocaml"><code>let l1 = [1;2;3;0;-1;-2;-3;0;1]</code></pre><p>is valid whereas</p><pre class="language-ocaml"><code>let l1 = [1;2;3;0;1;2;3;0;1]
let l2 = [0;1;2;3]
let l3 = [1;0;0;-1]</code></pre><p>are invalid.</p><p>Intuitively a list is valid it it is made of nonempty sublists of same-sign integers, switching between positive and negative, separated by zeros (see how much nicer the formal description is?)</p><p>The <i>grouping</i> of a valid list of integers is a list of integer <i>lists</i> which groups together the adjacent nonzero entries (and drops the zero entries). So, for example,</p><pre class="language-ocaml"><code>let l1_grouping = [[1;2;3];[-1;-2;-3];[1]]</code></pre><p>is the grouping for the valid list <code>l1</code> above.</p><div class="odoc-spec"><div class="spec value anchored" id="val-group"><a href="#val-group" class="anchor"></a><code><span><span class="keyword">val</span> group : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>int list</span> list</span> option</span></span></code></div><div class="spec-doc"><p>Implement a function <code>group</code> which given a list of integers <code>l</code>, returns the grouping of <code>l</code> given <code>l</code> is valid. The grouping should be returned as an <code>option</code>, where the output is <code>None</code> if the list is invalid.</p><p>Put your solution in a file called <code>assign03/lib/assign03_04.ml</code>. See the file <code>assign03/test/test_suite/test04.ml</code> for example output behavior.</p></div></div><h3 id="written-part"><a href="#written-part" class="anchor"></a>Written Part</h3><h4 id="problem-1:-typing-derivations"><a href="#problem-1:-typing-derivations" class="anchor"></a>Problem 1: Typing Derivations</h4><p>Write a derivation for the following typing judgment</p><div><pre class="odoc-katex-math display">    \{ \texttt{b} : \texttt{bool} \} \vdash
    \left(\texttt{let l i = [i; i + 1] in if b then l 0 else l 1}\right) \ : \ \texttt{int list}
    </pre></div><h4 id="problem-2:-semantic-derivations"><a href="#problem-2:-semantic-derivations" class="anchor"></a>Problem 2: Semantic Derivations</h4><p>Write a derivation for the following semantic judgment</p><div><pre class="odoc-katex-math display">    \left(\texttt{let (x, b) = (3, false) in let l = [x; x + x] in if b then [] else l}\right) \Downarrow \texttt{[3; 6]}
    </pre></div></div></body></html>
