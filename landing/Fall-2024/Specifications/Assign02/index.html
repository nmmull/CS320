<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Assign02 (Fall-2024.Specifications.Assign02)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../odoc.support/katex.min.css"/><script src="../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Fall-2024</a> &#x00BB; <a href="../index.html">Specifications</a> &#x00BB; Assign02</nav><header class="odoc-preamble"><h1>Module <code><span>Specifications.Assign02</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#assignment-2">Assignment 2</a><ul><li><a href="#programming-part">Programming Part</a><ul><li><a href="#problem-1:-tic-tac-toe">Problem 1: Tic-tac-toe</a></li><li><a href="#problem-2:-matrices">Problem 2: Matrices</a></li><li><a href="#problem-3:-walking-distance">Problem 3: Walking Distance</a></li></ul></li><li><a href="#written-part">Written Part</a><ul><li><a href="#problem-1:-typing-derivations">Problem 1: Typing Derivations</a></li><li><a href="#problem-2:-semantic-derivations">Problem 2: Semantic Derivations</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="assignment-2"><a href="#assignment-2" class="anchor"></a>Assignment 2</h2><p>This assignment is due on <b>Thursday 9/19 by 11:59PM</b>. It include both a programming part and a written part which are to be submitted on Gradescope under <i>assign02</i> and <i>assign02 (written)</i>, respectively.</p><h3 id="programming-part"><a href="#programming-part" class="anchor"></a>Programming Part</h3><h4 id="problem-1:-tic-tac-toe"><a href="#problem-1:-tic-tac-toe" class="anchor"></a>Problem 1: Tic-tac-toe</h4><p>The following is a small interface for a tic-tac-toe board. A board is represented as a tuple of rows (from top to bottom), a row is represented as a tuple of <code>pos</code>itions (from left to right) and a <code>pos</code>ition either has a <code>piece</code> or is <code>Blank</code>.</p><p>We will use <code>row_index</code> and <code>col_index</code> to refer to particular positions in the board.</p><div class="odoc-spec"><div class="spec type anchored" id="type-piece"><a href="#type-piece" class="anchor"></a><code><span><span class="keyword">type</span> piece</span><span> = </span></code><ol><li id="type-piece.X" class="def variant constructor anchored"><a href="#type-piece.X" class="anchor"></a><code><span>| </span><span><span class="constructor">X</span></span></code></li><li id="type-piece.O" class="def variant constructor anchored"><a href="#type-piece.O" class="anchor"></a><code><span>| </span><span><span class="constructor">O</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pos"><a href="#type-pos" class="anchor"></a><code><span><span class="keyword">type</span> pos</span><span> = </span></code><ol><li id="type-pos.Piece" class="def variant constructor anchored"><a href="#type-pos.Piece" class="anchor"></a><code><span>| </span><span><span class="constructor">Piece</span> <span class="keyword">of</span> <a href="#type-piece">piece</a></span></code></li><li id="type-pos.Blank" class="def variant constructor anchored"><a href="#type-pos.Blank" class="anchor"></a><code><span>| </span><span><span class="constructor">Blank</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-board"><a href="#type-board" class="anchor"></a><code><span><span class="keyword">type</span> board</span><span> = <span>(<a href="#type-pos">pos</a> * <a href="#type-pos">pos</a> * <a href="#type-pos">pos</a>)</span> * <span>(<a href="#type-pos">pos</a> * <a href="#type-pos">pos</a> * <a href="#type-pos">pos</a>)</span> * <span>(<a href="#type-pos">pos</a> * <a href="#type-pos">pos</a> * <a href="#type-pos">pos</a>)</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-row_index"><a href="#type-row_index" class="anchor"></a><code><span><span class="keyword">type</span> row_index</span><span> = </span></code><ol><li id="type-row_index.Top" class="def variant constructor anchored"><a href="#type-row_index.Top" class="anchor"></a><code><span>| </span><span><span class="constructor">Top</span></span></code></li><li id="type-row_index.Middle" class="def variant constructor anchored"><a href="#type-row_index.Middle" class="anchor"></a><code><span>| </span><span><span class="constructor">Middle</span></span></code></li><li id="type-row_index.Bottom" class="def variant constructor anchored"><a href="#type-row_index.Bottom" class="anchor"></a><code><span>| </span><span><span class="constructor">Bottom</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-col_index"><a href="#type-col_index" class="anchor"></a><code><span><span class="keyword">type</span> col_index</span><span> = </span></code><ol><li id="type-col_index.Left" class="def variant constructor anchored"><a href="#type-col_index.Left" class="anchor"></a><code><span>| </span><span><span class="constructor">Left</span></span></code></li><li id="type-col_index.Middle" class="def variant constructor anchored"><a href="#type-col_index.Middle" class="anchor"></a><code><span>| </span><span><span class="constructor">Middle</span></span></code></li><li id="type-col_index.Right" class="def variant constructor anchored"><a href="#type-col_index.Right" class="anchor"></a><code><span>| </span><span><span class="constructor">Right</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pos_index"><a href="#type-pos_index" class="anchor"></a><code><span><span class="keyword">type</span> pos_index</span><span> = <a href="#type-row_index">row_index</a> * <a href="#type-col_index">col_index</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_pos"><a href="#val-get_pos" class="anchor"></a><code><span><span class="keyword">val</span> get_pos : <span><a href="#type-board">board</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pos_index">pos_index</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-pos">pos</a></span></code></div><div class="spec-doc"><p>Implement the function <code>get_pos</code>, which given a board and a position index, returns the position at that index.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-winner"><a href="#val-winner" class="anchor"></a><code><span><span class="keyword">val</span> winner : <span><a href="#type-board">board</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Also implement the function <code>winner</code> which determines if there is a winner on a given board. Recall that a board has a winner if there are three of the same kind of piece in any row, column, or diagonal. It is not required that the board is valid. In particular, it doesn't matter if there are two winners, it just matters that the winning condition is met.</p><p>There is a long way to implement these functions. See if you can implement it a bit more elegantly.</p></div></div><p>Put your solution in a file called <code>assign02/lib/assign02_01.ml</code>. See the file <code>assign02/test/test_suite/test01.ml</code> for example output behavior. <b>Important:</b> Make sure to include the definitions the types above in your in your solution.</p><h4 id="problem-2:-matrices"><a href="#problem-2:-matrices" class="anchor"></a>Problem 2: Matrices</h4><p>The following is a simple record type for matrices. The (floating-point) entries of the matrix are stored in the field <code>entries</code> as a list of rows of equal length. The record type also has a field <code>rows</code> for the number of rows and <code>cols</code> for the number of columns.</p><div class="odoc-spec"><div class="spec type anchored" id="type-matrix"><a href="#type-matrix" class="anchor"></a><code><span><span class="keyword">type</span> matrix</span><span> = </span><span>{</span></code><ol><li id="type-matrix.entries" class="def record field anchored"><a href="#type-matrix.entries" class="anchor"></a><code><span>entries : <span><span>float list</span> list</span>;</span></code></li><li id="type-matrix.rows" class="def record field anchored"><a href="#type-matrix.rows" class="anchor"></a><code><span>rows : int;</span></code></li><li id="type-matrix.cols" class="def record field anchored"><a href="#type-matrix.cols" class="anchor"></a><code><span>cols : int;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_matrix"><a href="#val-mk_matrix" class="anchor"></a><code><span><span class="keyword">val</span> mk_matrix : <span><span>float list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * int)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-matrix">matrix</a></span></code></div><div class="spec-doc"><p>Implement the function <code>mk_matrix</code> which, given a list of floating-point <code>entries</code> and a pair of integers <code>(r, c)</code> representing a number of rows and a number of columns, constructs a matrix with <code>r</code> rows and <code>c</code> columns using the numbers in <code>entries</code>. That is, the first <code>r</code> numbers in <code>entries</code> make up the first row, the next <code>r</code> numbers make up the second row, and so on. You may assume that <code>entries</code> is length <code>r * c</code>. The behavior of the implementation is undefined otherwise.</p><pre class="language-ocaml"><code>let _ =
  let a = mk_matrix [1.;0.;0.;1.] (2, 2) in
  let b = {entries = [[1.;0.];[0.;1.]]; rows = 2; cols = 2} in
  assert (a = b)</code></pre><p>Put your solution in a file called <code>assign02/lib/assign02_02.ml</code>. See the file <code>assign02/test/test_suite/test02.ml</code> for more example output behavior. <b>Important:</b> Make sure to include the definition of <code>matrix</code> in your solution.</p></div></div><h4 id="problem-3:-walking-distance"><a href="#problem-3:-walking-distance" class="anchor"></a>Problem 3: Walking Distance</h4><p>The following is a simple variant type for the cardinal directions, along with a type synonym for a path represented as a list of directions. We think of a path as representing a walk along a grid, with each direction in the path representing one step in this grid. To be concrete, we will presume that one &quot;step&quot; is 1 meter (i.e., <code>North</code> is interpreted to mean &quot;walk 1 meter north&quot;). Note that a path may backtrack and intersect with itself.</p><div class="odoc-spec"><div class="spec type anchored" id="type-dir"><a href="#type-dir" class="anchor"></a><code><span><span class="keyword">type</span> dir</span><span> = </span></code><ol><li id="type-dir.North" class="def variant constructor anchored"><a href="#type-dir.North" class="anchor"></a><code><span>| </span><span><span class="constructor">North</span></span></code></li><li id="type-dir.South" class="def variant constructor anchored"><a href="#type-dir.South" class="anchor"></a><code><span>| </span><span><span class="constructor">South</span></span></code></li><li id="type-dir.East" class="def variant constructor anchored"><a href="#type-dir.East" class="anchor"></a><code><span>| </span><span><span class="constructor">East</span></span></code></li><li id="type-dir.West" class="def variant constructor anchored"><a href="#type-dir.West" class="anchor"></a><code><span>| </span><span><span class="constructor">West</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span><span> = <span><a href="#type-dir">dir</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dist"><a href="#val-dist" class="anchor"></a><code><span><span class="keyword">val</span> dist : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Implement the function <code>dist</code> which, given a list of directions <code>dirs</code>, computes the <code class="odoc-katex-math">\ell_2</code> distance (i.e., &quot;as the crow flies&quot;) in meters between the starting point and ending point of the path given by <code>dirs</code>. Note that it doesn't matter where you start, the distance between the starting and ending points will always be the same.</p><pre class="language-ocaml"><code>(* We'll use an unnecessarily large error margin *)
let is_close f1 f2 = abs_float (f1 -. f2) &lt; 0.000001

let _ = assert (is_close (dist [North; North; South; East]) (sqrt 2.))</code></pre><p>Put your solution in a file called <code>assign02/lib/assign02_03.ml</code>. See the file <code>assign02/test/test_suite/test03.ml</code> for more example output behavior. <b>Important:</b> Make sure to include the definitions of <code>dir</code> and <code>path</code> in your solution.</p></div></div><h3 id="written-part"><a href="#written-part" class="anchor"></a>Written Part</h3><h4 id="problem-1:-typing-derivations"><a href="#problem-1:-typing-derivations" class="anchor"></a>Problem 1: Typing Derivations</h4><p>Write a derivation of the typing judgment</p><div><pre class="odoc-katex-math display">    \{\texttt{z} : \texttt{int}\} \vdash \left(\texttt{let x = z + 5 in let y = &quot;five&quot; in (x + z, y)}\right) : \texttt{int * string}
    </pre></div><h4 id="problem-2:-semantic-derivations"><a href="#problem-2:-semantic-derivations" class="anchor"></a>Problem 2: Semantic Derivations</h4><p>Write a derivation of the semantic judgment</p><div><pre class="odoc-katex-math display">    \left(\texttt{let x = 5 in let z = x + x in (x * z, z)}\right) \Downarrow \texttt{(50, 10)}
    </pre></div></div></body></html>
