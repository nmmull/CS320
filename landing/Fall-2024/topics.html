<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>topics (Fall-2024.topics)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">Fall-2024</a> &#x00BB; topics</nav><header class="odoc-preamble"><h2 id="topics"><a href="#topics" class="anchor"></a>Topics</h2></header><nav class="odoc-toc"><ul><li><a href="#course_intro">Course Introduction</a></li><li><a href="#beginning-ocaml">Beginning Ocaml</a><ul><li><a href="#ocaml_intro_i">The Basics</a></li><li><a href="#ocaml_intro_ii">Let Expressions</a></li><li><a href="#ocaml_intro_iii">Unions and Products</a></li><li><a href="#ocaml_intro_iv">Lists, Tail Recursion</a></li></ul></li><li><a href="#adt">Algebraic Data Types</a></li><li><a href="#poly">Polymorphism</a></li><li><a href="#higher-order-programming">Higher Order Programming</a><ul><li><a href="#hop_i">Maps and Filters</a></li><li><a href="#hop_ii">Folds</a></li></ul></li><li><a href="#mod">Modules and Monads</a></li><li><a href="#prog">Progress and Preservation</a></li><li><a href="#parsing">Parsing</a><ul><li><a href="#parse_i">Formal Grammar</a></li><li><a href="#parse_ii">Lexer/Parser Generators</a></li></ul></li><li><a href="#formal-semantics">Formal Semantics</a><ul><li><a href="#sem_i">Operational Semantics</a></li><li><a href="#sem_ii">The Substitution Model</a></li><li><a href="#sem_iii">Variables, Scope, Closures</a></li><li><a href="#sem_iv">Closures and the Environment Model</a></li></ul></li><li><a href="#type-checking">Type Checking</a><ul><li><a href="#type_check_i">Introduction</a></li><li><a href="#type_check_ii">In Practice</a></li></ul></li><li><a href="#type-inference">Type Inference</a><ul><li><a href="#type_inf_i">Introduction</a></li><li><a href="#type_inf_ii">Unification</a></li><li><a href="#type_inf_iii">In Practice</a></li></ul></li><li><a href="#compilation">Compilation</a><ul><li><a href="#comp_i">Stack-Based Languages</a></li><li><a href="#comp_ii">In Practice</a></li></ul></li><li><a href="#adv">Advanced Topic: TBA</a></li></ul></nav><div class="odoc-content"><h3 id="course_intro"><a href="#course_intro" class="anchor"></a>Course Introduction</h3><p>We describe what this course is about, including how the course is structured, a rough outline of the topics, and high-level remarks about the study of programming languages. We also introduce OCaml, including how to work with <code>utop</code>, how to compile simple programs, and how to write basic expressions.</p><p><b>Reading:</b></p><ul><li>OCP 1.1: <a href="https://cs3110.github.io/textbook/chapters/intro/past.html">The Past of OCaml</a></li><li>OCP 1.2: <a href="https://cs3110.github.io/textbook/chapters/intro/present.html">The Present of OCaml</a></li><li>OCP 1.3: <a href="https://cs3110.github.io/textbook/chapters/intro/future.html">Look to Your Future</a></li><li>OCP 2.1: <a href="https://cs3110.github.io/textbook/chapters/basics/toplevel.html">The OCaml Toplevel</a></li><li>OCP 2.2: <a href="https://cs3110.github.io/textbook/chapters/basics/compiling.html">Compiling OCaml Programs</a> (excluding 2.2.3)</li><li>OCP 2.3: <a href="https://cs3110.github.io/textbook/chapters/basics/expressions.html">Expressions</a></li></ul><h3 id="beginning-ocaml"><a href="#beginning-ocaml" class="anchor"></a>Beginning Ocaml</h3><h4 id="ocaml_intro_i"><a href="#ocaml_intro_i" class="anchor"></a>The Basics</h4><p>We look at the basic constructs we need to start writing more interesting OCaml programs, and work through some examples. We start to see how the typing rules and semantics of OCaml work. We also introduce dune (which we'll be using for assignments).</p><p><b>Reading:</b></p><ul><li>OCP 2.2: <a href="https://cs3110.github.io/textbook/chapters/basics/compiling.html">Compiling OCaml Programs</a> (including 2.2.3)</li><li>OCP 2.4: <a href="https://cs3110.github.io/textbook/chapters/basics/functions.html">Functions</a> (excluding 2.4.4, 2.4.6)</li><li>OCP 2.6: <a href="https://cs3110.github.io/textbook/chapters/basics/printing.html">Printing</a></li></ul><h4 id="ocaml_intro_ii"><a href="#ocaml_intro_ii" class="anchor"></a>Let Expressions</h4><p>We explore further the notion of expressions in OCaml (everything is an expression in OCaml). In particular, we look at let expressions as a way of using local variables. We continue to emphasize that as we introduce more programming abstractions, we have to formally present their syntax, typing, and semantics.</p><ul><li>OCP 2.3: <a href="https://cs3110.github.io/textbook/chapters/basics/expressions.html">Expressions</a></li></ul><h4 id="ocaml_intro_iii"><a href="#ocaml_intro_iii" class="anchor"></a>Unions and Products</h4><p>We look at various ways of organizing data in OCaml including simple variants, data-carrying variants, tuples, records. We also introduced the notion of a <i>pattern</i> (which is is <i>not</i> the same thing as an expression, though it behaves similarly with respect to typing).</p><p><b>Reading:</b></p><ul><li>OCP 3.2: <a href="https://cs3110.github.io/textbook/chapters/data/variants.html">Variants</a></li><li>OCP 3.4: <a href="https://cs3110.github.io/textbook/chapters/data/records_tuples.html">Records and Tuples</a></li><li>OCP 3.6: <a href="https://cs3110.github.io/textbook/chapters/data/type_synonym.html">Type Synonyms</a> (not covered in lecture)</li><li>OCP 3.9: <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">Algebraic Data Types</a> (only 3.9.1)</li></ul><h4 id="ocaml_intro_iv"><a href="#ocaml_intro_iv" class="anchor"></a>Lists, Tail Recursion</h4><p>We introduce the familiar notion of lists in OCaml, emphasizing that <b>lists are immutable</b> in OCaml. We also talk about tail recursion, how to write tail recursive functions, and why we might want to.</p><p><b>Reading:</b></p><ul><li>OCP 3.1: <a href="https://cs3110.github.io/textbook/chapters/data/lists.html">Lists</a></li><li>OCP 3.5: <a href="https://cs3110.github.io/textbook/chapters/data/pattern_matching_advanced.html">Advanced Pattern Matching</a></li><li>OCP 3.7: <a href="https://cs3110.github.io/textbook/chapters/data/options.html">Options</a></li><li>OCP 3.8: <a href="https://cs3110.github.io/textbook/chapters/data/assoc_list.html">Association Lists</a></li></ul><h3 id="adt"><a href="#adt" class="anchor"></a>Algebraic Data Types</h3><p>We introduce algebraic data types as a way of defining recursive and parameterized data types. We look at many examples. (<i>Note.</i> ADTs are fundamental to functional programming, this is where we really start to see OCaml shine)</p><p><b>Reading:</b></p><ul><li>OCP 3.9: <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">Algebraic Data Types</a> (excluding 3.9.6)</li><li>OCP 3.11: <a href="https://cs3110.github.io/textbook/chapters/data/trees.html">Example: Trees</a></li><li>OCP 8.3: <a href="https://cs3110.github.io/textbook/chapters/ds/rb.html">Red-Black Trees</a> (only 8.3.1: Binary Search Trees)</li></ul><h3 id="poly"><a href="#poly" class="anchor"></a>Polymorphism</h3><p>Many of the programs that we've written so far used specific types like <code>int</code>, <code>string</code>, and <code>bool</code>. We take a moment to discuss <i>polymorphism</i> more formally, and how to use polymorphism to write more general programs.</p><h3 id="higher-order-programming"><a href="#higher-order-programming" class="anchor"></a>Higher Order Programming</h3><h4 id="hop_i"><a href="#hop_i" class="anchor"></a>Maps and Filters</h4><p>We introduce the notion of higher-order functions, i.e., functions which take other functions as arguments. There are three common higher-order functions used in programming, we cover the first two: <code>map</code> and <code>filter</code> for lists.</p><p><b>Reading:</b></p><ul><li>OCP 4.1: <a href="https://cs3110.github.io/textbook/chapters/hop/higher_order.html">Higher-Order Functions</a></li><li>OCP 4.2: <a href="https://cs3110.github.io/textbook/chapters/hop/map.html">Map</a></li><li>OCP 4.3: <a href="https://cs3110.github.io/textbook/chapters/hop/filter.html">Filter</a></li><li>OCP 4.7: <a href="https://cs3110.github.io/textbook/chapters/hop/currying.html">Currying</a></li></ul><h4 id="hop_ii"><a href="#hop_ii" class="anchor"></a>Folds</h4><p>We cover the last (and most complex) of the common higher-order functions: <code>fold_left</code> and <code>fold_right</code> for lists. We also look at how higher-order functions can be useful for things other than lists.</p><p><b>Reading:</b></p><ul><li>OCP 4.4: <a href="https://cs3110.github.io/textbook/chapters/hop/fold.html">Fold</a></li><li>OCP 4.5: <a href="https://cs3110.github.io/textbook/chapters/hop/beyond_lists.html">Beyond Lists</a></li></ul><h3 id="mod"><a href="#mod" class="anchor"></a>Modules and Monads</h3><p>We introduce modules as a way of organizing OCaml code. We see at how modules can also be used to organize interfaces for data structures.</p><p>We also introduce monads as a way to more elegantly deal with <code>option</code>s in functional code. We show how to use <code>let*</code> syntax in OCaml to make code easier to follow.</p><p><b>Reading:</b></p><ul><li>OCP 5.1: <a href="https://cs3110.github.io/textbook/chapters/modules/module_systems.html">Module Systems</a></li><li>OCP 5.2: <a href="https://cs3110.github.io/textbook/chapters/modules/modules.html">Modules</a></li><li>OCP 5.3: <a href="https://cs3110.github.io/textbook/chapters/modules/toplevel.html">Modules and the Toplevel</a> (only 5.3.1, 5.3.2)</li><li>OCP 5.4: <a href="https://cs3110.github.io/textbook/chapters/modules/encapsulation.html">Encapsulation</a> (excluding 5.4.3)</li><li>OCP 5.5: <a href="https://cs3110.github.io/textbook/chapters/modules/functional_data_structures.html">Functional Data Structures</a> (only 5.6.2)</li></ul><h3 id="prog"><a href="#prog" class="anchor"></a>Progress and Preservation</h3><p>We take our last lecture before the midterm to discuss the notions of progress and preservation. These theorems express that well-typed programs are well-behaved, and hold for any <i>good</i> programming languages. Professor Das also takes a moment to lament about programming languages.</p><h3 id="parsing"><a href="#parsing" class="anchor"></a>Parsing</h3><h4 id="parse_i"><a href="#parse_i" class="anchor"></a>Formal Grammar</h4><p>We introduce the second half of the course, including the full interpretation pipeline. We then start at the beginning of the pipeline (i.e., <i>parsing</i>) looking at (E)BNF grammars, ambiguity, and precedence.</p><p><b>Reading:</b></p><ul><li><a href="https://nmmull.github.io/PL-at-BU/Intro/notes.html">The Interpretation Pipeline</a> (draft)</li><li><a href="https://nmmull.github.io/PL-at-BU/Formal-Grammar/notes.html">Formal Grammar</a> (draft)</li></ul><h4 id="parse_ii"><a href="#parse_ii" class="anchor"></a>Lexer/Parser Generators</h4><p>We look more carefully at the difference between lexing and parsing. We then see how to use <code>ocamllex</code> and <code>menhir</code> to generate lexers and parsers for a grammar (in particular, how to deal with ambiguity and precedence). (<i>Note.</i> We will use these tools for <i>every</i> interpreter we build, so it is important to become comfortable with them)</p><p><b>Reading:</b></p><ul><li>OCP 9.2: <a href="https://cs3110.github.io/textbook/chapters/interp/parsing.html">Parsing</a></li><li><a href="https://nmmull.github.io/PL-at-BU/Parsing/notes.html">Parser Generators</a> (draft)</li></ul><h3 id="formal-semantics"><a href="#formal-semantics" class="anchor"></a>Formal Semantics</h3><h4 id="sem_i"><a href="#sem_i" class="anchor"></a>Operational Semantics</h4><p>We introduce operational semantics (both small-step and big-step) as a way of formally specifying the behavior of executing a programming language. We give some examples of derivations for various semantics.</p><p><b>Reading:</b></p><ul><li>OCP 9.1: <a href="https://cs3110.github.io/textbook/chapters/interp/calculator.html">Example: Calculator</a></li></ul><h4 id="sem_ii"><a href="#sem_ii" class="anchor"></a>The Substitution Model</h4><p>We look the lambda calculus, its syntax and semantics. We also discuss capture-avoiding substitution as a way of dealing with some of the more subtle details of evaluating expressions in the lambda calculus.</p><p><b>Reading:</b></p><ul><li>OCP 9.3: <a href="https://cs3110.github.io/textbook/chapters/interp/substitution.html">Substitution Model</a></li></ul><h4 id="sem_iii"><a href="#sem_iii" class="anchor"></a>Variables, Scope, Closures</h4><p>We discuss (dynamic and lexical) scoping, with an emphasis on how variable scoping is dealt with in OCaml. We consider how this connects to call-by-value semantics and closures.</p><p><b>Reading:</b></p><ul><li>OCP 9.4: <a href="https://cs3110.github.io/textbook/chapters/interp/environment.html#lexical-vs-dynamic-scope">Environment Model</a> (up to 9.4.2)</li></ul><h4 id="sem_iv"><a href="#sem_iv" class="anchor"></a>Closures and the Environment Model</h4><p>We further discuss closures as a way to better implement lexical scoping in functional programming languages. We introduce the environment model as a more efficient alternative to the substitution model from the previous week.</p><p><b>Reading:</b></p><ul><li>OCP 9.4: <a href="https://cs3110.github.io/textbook/chapters/interp/environment.html#lexical-vs-dynamic-scope">Environment Model</a></li></ul><h3 id="type-checking"><a href="#type-checking" class="anchor"></a>Type Checking</h3><h4 id="type_check_i"><a href="#type_check_i" class="anchor"></a>Introduction</h4><p>We look even more carefully at the notion of a typing derivation.</p><h4 id="type_check_ii"><a href="#type_check_ii" class="anchor"></a>In Practice</h4><p>We look at the practical considerations of type checking.</p><p><b>Reading:</b></p><ul><li>OCP 9.5: <a href="https://cs3110.github.io/textbook/chapters/interp/typecheck.html">Type Checking</a></li></ul><h3 id="type-inference"><a href="#type-inference" class="anchor"></a>Type Inference</h3><h4 id="type_inf_i"><a href="#type_inf_i" class="anchor"></a>Introduction</h4><p>We discuss type inference and let-polymorphism (potentially non-polymorphic lets).</p><h4 id="type_inf_ii"><a href="#type_inf_ii" class="anchor"></a>Unification</h4><p>We discuss more generally the notion of unification, which underlies the type inference algorithm we will be implementing.</p><h4 id="type_inf_iii"><a href="#type_inf_iii" class="anchor"></a>In Practice</h4><p>We look at practical considerations in the implementation of a type inference algorithm.</p><p><b>Reading:</b></p><ul><li>OCP 9.6: <a href="https://cs3110.github.io/textbook/chapters/interp/inference.html">Type Inference</a></li></ul><h3 id="compilation"><a href="#compilation" class="anchor"></a>Compilation</h3><h4 id="comp_i"><a href="#comp_i" class="anchor"></a>Stack-Based Languages</h4><p>We discuss stack-oriented languages in general and introduce the syntax and semantics of a basic stack-oriented language with procedures.</p><h4 id="comp_ii"><a href="#comp_ii" class="anchor"></a>In Practice</h4><p>We give a high-level introduction of compilation and its relation to interpretation and work through some simple examples. We then go through an example of building a simple byte-code interpreter.</p><h3 id="adv"><a href="#adv" class="anchor"></a>Advanced Topic: TBA</h3><p>In our last lecture, we cover an advanced topic based on the 300-400 level PL courses being offered in the spring.</p></div></body></html>
