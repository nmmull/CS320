<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>topics (Fall-2024.topics)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">Fall-2024</a> &#x00BB; topics</nav><header class="odoc-preamble"><h2 id="topics"><a href="#topics" class="anchor"></a>Topics</h2></header><nav class="odoc-toc"><ul><li><a href="#course_intro">Course Introduction</a></li><li><a href="#beginning-ocaml">Beginning Ocaml</a><ul><li><a href="#ocaml_intro_i">The Basics</a></li><li><a href="#ocaml_intro_ii">Let Expressions</a></li><li><a href="#ocaml_intro_iii">Unions and Products</a></li><li><a href="#ocaml_intro_iv">Lists, Tail Recursion</a></li></ul></li><li><a href="#adt">Algebraic Data Types</a></li><li><a href="#poly">Polymorphism</a></li><li><a href="#higher-order-programming">Higher Order Programming</a><ul><li><a href="#hop_i">Maps and Filters</a></li><li><a href="#hop_ii">Folds</a></li></ul></li><li><a href="#mod">Modular Programming</a></li><li><a href="#monads">Introduction to Monads</a></li><li><a href="#prog">Progress and Preservation</a></li><li><a href="#parsing">Parsing</a><ul><li><a href="#parse_i">Formal Grammar</a></li><li><a href="#parse_ii">Lexer/Parser Generators</a></li></ul></li><li><a href="#formal-semantics">Formal Semantics</a><ul><li><a href="#sem_i">Operational Semantics</a></li><li><a href="#sem_ii">The Substitution Model</a></li><li><a href="#sem_iii">Variables, Scope, Parameter Passing</a></li><li><a href="#sem_iv">Closures and the Environment Model</a></li></ul></li><li><a href="#type-checking">Type Checking</a><ul><li><a href="#type_check_i">Introduction</a></li><li><a href="#type_check_ii">In Practice</a></li></ul></li><li><a href="#type-inference">Type Inference</a><ul><li><a href="#type_inf_i">Introduction</a></li><li><a href="#type_inf_ii">Unification</a></li><li><a href="#type_inf_iii">In Practice</a></li></ul></li><li><a href="#compilation">Compilation</a><ul><li><a href="#comp_i">Stack-Based Languages</a></li><li><a href="#comp_ii">In Practice</a></li></ul></li><li><a href="#adv">Advanced Topic: TBA</a></li></ul></nav><div class="odoc-content"><h3 id="course_intro"><a href="#course_intro" class="anchor"></a>Course Introduction</h3><p>We describe what this course is about, including how the course is structured, a rough outline of the topics, and high-level remarks about the study of programming languages. We also introduce OCaml, including how to work with <code>utop</code>, how to compile simple programs, and how to write basic expressions.</p><p><b>Reading:</b></p><ul><li>OCP 1.1: <a href="https://cs3110.github.io/textbook/chapters/intro/past.html">The Past of OCaml</a></li><li>OCP 1.2: <a href="https://cs3110.github.io/textbook/chapters/intro/present.html">The Present of OCaml</a></li><li>OCP 1.3: <a href="https://cs3110.github.io/textbook/chapters/intro/future.html">Look to Your Future</a></li><li>OCP 2.1: <a href="https://cs3110.github.io/textbook/chapters/basics/toplevel.html">The OCaml Toplevel</a></li><li>OCP 2.2: <a href="https://cs3110.github.io/textbook/chapters/basics/compiling.html">Compiling OCaml Programs</a> (excluding 2.2.3)</li><li>OCP 2.3: <a href="https://cs3110.github.io/textbook/chapters/basics/expressions.html">Expressions</a></li></ul><h3 id="beginning-ocaml"><a href="#beginning-ocaml" class="anchor"></a>Beginning Ocaml</h3><h4 id="ocaml_intro_i"><a href="#ocaml_intro_i" class="anchor"></a>The Basics</h4><p>We look at the basic constructs we need to start writing more interesting OCaml programs, and work through some examples. We start to see how the typing rules and semantics of OCaml work. We also introduce dune (which we'll be using this for assignments).</p><p><b>Reading:</b></p><ul><li>OCP 2.2: <a href="https://cs3110.github.io/textbook/chapters/basics/compiling.html">Compiling OCaml Programs</a> (including 2.2.3)</li><li>OCP 2.4: <a href="https://cs3110.github.io/textbook/chapters/basics/functions.html">Functions</a> (excluding 2.4.4, 2.4.6)</li><li>OCP 2.6: <a href="https://cs3110.github.io/textbook/chapters/basics/printing.html">Printing</a></li></ul><h4 id="ocaml_intro_ii"><a href="#ocaml_intro_ii" class="anchor"></a>Let Expressions</h4><p>We explore further the notion of expressions in OCaml (everything is an expression in OCaml). In particuluar, we look at let expressions as a way of using local variables. We continue to emphasize that as we introduce more programming abstractions, we have to formally present their syntax, typing, and semantics.</p><ul><li>OCP 2.3: <a href="https://cs3110.github.io/textbook/chapters/basics/expressions.html">Expressions</a></li></ul><h4 id="ocaml_intro_iii"><a href="#ocaml_intro_iii" class="anchor"></a>Unions and Products</h4><p>We look at various ways of organizing data in OCaml including simple variants, data-carrying variants, tuples, records. We also introduced the notion of a <i>pattern</i> (which is is <i>not</i> the same thing as an expression, though it behaves similarly with respect to typing).</p><p><b>Reading:</b></p><ul><li>OCP 3.2: <a href="https://cs3110.github.io/textbook/chapters/data/variants.html">Variants</a></li><li>OCP 3.4: <a href="https://cs3110.github.io/textbook/chapters/data/records_tuples.html">Records and Tuples</a></li><li>OCP 3.6: <a href="https://cs3110.github.io/textbook/chapters/data/type_synonym.html">Type Synonyms</a> (not covered in lecture)</li><li>OCP 3.9: <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">Algebraic Data Types</a> (only 3.9.1)</li></ul><h4 id="ocaml_intro_iv"><a href="#ocaml_intro_iv" class="anchor"></a>Lists, Tail Recursion</h4><p>We introduce the familiar notion of lists in OCaml, emphasizing that <b>lists are immutable</b> in OCaml. We also talk about tail recursion, how to write tail recursive functions, and why we might want to.</p><p><b>Reading:</b></p><ul><li>OCP 3.1: <a href="https://cs3110.github.io/textbook/chapters/data/lists.html">Lists</a></li><li>OCP 3.5: <a href="https://cs3110.github.io/textbook/chapters/data/pattern_matching_advanced.html">Advanced Pattern Matching</a></li><li>OCP 3.7: <a href="https://cs3110.github.io/textbook/chapters/data/options.html">Options</a></li><li>OCP 3.8: <a href="https://cs3110.github.io/textbook/chapters/data/assoc_list.html">Association Lists</a></li></ul><h3 id="adt"><a href="#adt" class="anchor"></a>Algebraic Data Types</h3><p>We introduce algebraic data types as a way of defining recursive and parameterized data types. We look at many examples. (<i>Note.</i> ADTs are fundamental to functional programming, this is where we really start to see OCaml shine)</p><p><b>Reading:</b></p><ul><li>OCP 3.9: <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">Algebraic Data Types</a> (excluding 3.9.6)</li><li>OCP 3.11: <a href="https://cs3110.github.io/textbook/chapters/data/trees.html">Example: Trees</a></li><li>OCP 8.3: <a href="https://cs3110.github.io/textbook/chapters/ds/rb.html">Red-Black Trees</a> (only 8.3.1: Binary Search Trees)</li></ul><h3 id="poly"><a href="#poly" class="anchor"></a>Polymorphism</h3><p>We take a moment to discuss more formally the notion of polymorphism.</p><h3 id="higher-order-programming"><a href="#higher-order-programming" class="anchor"></a>Higher Order Programming</h3><h4 id="hop_i"><a href="#hop_i" class="anchor"></a>Maps and Filters</h4><p>We introduce the notion of higher-order functions, i.e., functions which take other functions as arguments. There are three common higher-order functions used in programming, we cover the first two: <code>map</code> and <code>filter</code> for lists.</p><p><b>Reading:</b></p><ul><li>OCP 4.1: <a href="https://cs3110.github.io/textbook/chapters/hop/higher_order.html">Higher-Order Functions</a></li><li>OCP 4.2: <a href="https://cs3110.github.io/textbook/chapters/hop/map.html">Map</a></li><li>OCP 4.3: <a href="https://cs3110.github.io/textbook/chapters/hop/filter.html">Filter</a></li><li>OCP 4.7: <a href="https://cs3110.github.io/textbook/chapters/hop/currying.html">Currying</a></li></ul><h4 id="hop_ii"><a href="#hop_ii" class="anchor"></a>Folds</h4><p>We cover the last (and most complex) of the common higher-order functions: <code>fold_left</code> and <code>fold_right</code> for lists. We also look at how higher-order functions can be useful for things other than lists.</p><p><b>Reading:</b></p><ul><li>OCP 4.4: <a href="https://cs3110.github.io/textbook/chapters/hop/fold.html">Fold</a></li><li>OCP 4.5: <a href="https://cs3110.github.io/textbook/chapters/hop/beyond_lists.html">Beyond Lists</a></li></ul><h3 id="mod"><a href="#mod" class="anchor"></a>Modular Programming</h3><p>We introduce modules as a way of organizing OCaml code. We will need to know how modules work for the mini-projects in the second-half of the course. We see at how modules can also be used to organize interfaces for data structures. We also look a bit at the relationship between dune and toplevel.</p><p><b>Reading:</b></p><ul><li>OCP 5.1: <a href="https://cs3110.github.io/textbook/chapters/modules/module_systems.html">Module Systems</a></li><li>OCP 5.2: <a href="https://cs3110.github.io/textbook/chapters/modules/modules.html">Modules</a></li><li>OCP 5.3: <a href="https://cs3110.github.io/textbook/chapters/modules/toplevel.html">Modules and the Toplevel</a> (only 5.3.1, 5.3.2)</li><li>OCP 5.4: <a href="https://cs3110.github.io/textbook/chapters/modules/encapsulation.html">Encapsulation</a> (excluding 5.4.3)</li><li>OCP 5.5: <a href="https://cs3110.github.io/textbook/chapters/modules/functional_data_structures.html">Functional Data Structures</a> (only 5.6.2)</li></ul><h3 id="monads"><a href="#monads" class="anchor"></a>Introduction to Monads</h3><p>We introduce monads as a way to more elegantly deal with <code>option</code>s in functional code. We show how to use <code>let*</code> syntax in OCaml to make code easier to follow.</p><h3 id="prog"><a href="#prog" class="anchor"></a>Progress and Preservation</h3><p>We take our last lecture before the midterm to discuss the notions of progress and preservation.</p><h3 id="parsing"><a href="#parsing" class="anchor"></a>Parsing</h3><h4 id="parse_i"><a href="#parse_i" class="anchor"></a>Formal Grammar</h4><p>We introduce the second half of the course, including the full interpretation pipeline. We then start at the beginning of the pipeline (i.e., <i>parsing</i>) looking at (E)BNF grammars, ambiguity, and precedence.</p><h4 id="parse_ii"><a href="#parse_ii" class="anchor"></a>Lexer/Parser Generators</h4><p>We look more carefully at the difference between lexing and parsing. We then see how to use <code>menhir</code> to generate lexers and parsers for a grammar (in particular, how to deal with ambiguity and precedence). (<i>Note.</i> We will use <code>menhir</code> for <i>every</i> interpreter we build, so it is important to become comfortable with this tool)</p><p><b>Reading:</b></p><ul><li>OCP 9.2: <a href="https://cs3110.github.io/textbook/chapters/interp/parsing.html">Parsing</a></li></ul><h3 id="formal-semantics"><a href="#formal-semantics" class="anchor"></a>Formal Semantics</h3><h4 id="sem_i"><a href="#sem_i" class="anchor"></a>Operational Semantics</h4><p>We introduce operational semantics (both small-step and big-step) as a way of formally specifying the behavior of executing a programming language. We give some examples of derivations for various semantics.</p><p><b>Reading:</b></p><ul><li>OCP 9.1: <a href="https://cs3110.github.io/textbook/chapters/interp/calculator.html">Example: Calculator</a></li></ul><h4 id="sem_ii"><a href="#sem_ii" class="anchor"></a>The Substitution Model</h4><p>We work again through the untyped lambda calculus, this time with the formal machinery from last lecture. We look at capture-avoiding substitution and (if we have time) DeBruijn indices as ways of dealing with some of the more subtle details of evaluating expressions in the lambda calculus.</p><p><b>Reading:</b></p><ul><li>OCP 9.3: <a href="https://cs3110.github.io/textbook/chapters/interp/substitution.html">Substitution Model</a></li></ul><h4 id="sem_iii"><a href="#sem_iii" class="anchor"></a>Variables, Scope, Parameter Passing</h4><p>We discuss (dynamic and lexical) scoping, but with an emphasis on how variable scoping is dealt with in OCaml. We also consider the general problem of passing parameters to functions when they they are called, and look specifically at the call-by-name and call-by-value evaluation strategies in the functional setting.</p><p><b>Reading:</b></p><ul><li>OCP 9.4: <a href="https://cs3110.github.io/textbook/chapters/interp/environment.html#lexical-vs-dynamic-scope">Environment Model</a> (up to 9.4.2)</li></ul><h4 id="sem_iv"><a href="#sem_iv" class="anchor"></a>Closures and the Environment Model</h4><p>We introduce closures as a way to correctly implement lexical scoping in functional programming languages. We introduce the environment model as a more efficient alternative to the substitution model from the previous week.</p><p><b>Reading:</b></p><ul><li>OCP 9.4: <a href="https://cs3110.github.io/textbook/chapters/interp/environment.html#lexical-vs-dynamic-scope">Environment Model</a></li></ul><h3 id="type-checking"><a href="#type-checking" class="anchor"></a>Type Checking</h3><h4 id="type_check_i"><a href="#type_check_i" class="anchor"></a>Introduction</h4><p>We look even more carefully at the notion of a typing derivation.</p><h4 id="type_check_ii"><a href="#type_check_ii" class="anchor"></a>In Practice</h4><p>We look at the practical considerations of type checking.</p><p><b>Reading:</b></p><ul><li>OCP 9.5: <a href="https://cs3110.github.io/textbook/chapters/interp/typecheck.html">Type Checking</a></li></ul><h3 id="type-inference"><a href="#type-inference" class="anchor"></a>Type Inference</h3><h4 id="type_inf_i"><a href="#type_inf_i" class="anchor"></a>Introduction</h4><p>We discuss type inference and let-polymorphism (potentially non-polymorphic lets).</p><h4 id="type_inf_ii"><a href="#type_inf_ii" class="anchor"></a>Unification</h4><p>We discuss more generally the notion of unification, which underlies the type inference algorithm we will be implementing</p><h4 id="type_inf_iii"><a href="#type_inf_iii" class="anchor"></a>In Practice</h4><p>We look at practical considerations in the implementation of a type inference algorithm.</p><p><b>Reading:</b></p><ul><li>OCP 9.6: <a href="https://cs3110.github.io/textbook/chapters/interp/inference.html">Type Inference</a></li></ul><h3 id="compilation"><a href="#compilation" class="anchor"></a>Compilation</h3><h4 id="comp_i"><a href="#comp_i" class="anchor"></a>Stack-Based Languages</h4><p>We discuss stack-oriented languages in general and introduce the syntax and semantics of a basic stack-oriented language with procedures.</p><h4 id="comp_ii"><a href="#comp_ii" class="anchor"></a>In Practice</h4><p>We give a high-level introduction of compilation and its relation to interpretation and work through some simple examples. We then go through an example of building a simple byte-code interpreter.</p><h3 id="adv"><a href="#adv" class="anchor"></a>Advanced Topic: TBA</h3><p>In our last lecture, we cover an advanced topic based on the 300-400 level PL courses being offered in the spring.</p></div></body></html>
